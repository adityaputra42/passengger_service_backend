// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"pasengger_service/ent/migrate"

	"pasengger_service/ent/aircraft"
	"pasengger_service/ent/airport"
	"pasengger_service/ent/booking"
	"pasengger_service/ent/bookingpassenger"
	"pasengger_service/ent/flight"
	"pasengger_service/ent/flightseat"
	"pasengger_service/ent/passenger"
	"pasengger_service/ent/payment"
	"pasengger_service/ent/seats"
	"pasengger_service/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Aircraft is the client for interacting with the Aircraft builders.
	Aircraft *AircraftClient
	// Airport is the client for interacting with the Airport builders.
	Airport *AirportClient
	// Booking is the client for interacting with the Booking builders.
	Booking *BookingClient
	// BookingPassenger is the client for interacting with the BookingPassenger builders.
	BookingPassenger *BookingPassengerClient
	// Flight is the client for interacting with the Flight builders.
	Flight *FlightClient
	// FlightSeat is the client for interacting with the FlightSeat builders.
	FlightSeat *FlightSeatClient
	// Passenger is the client for interacting with the Passenger builders.
	Passenger *PassengerClient
	// Payment is the client for interacting with the Payment builders.
	Payment *PaymentClient
	// Seats is the client for interacting with the Seats builders.
	Seats *SeatsClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Aircraft = NewAircraftClient(c.config)
	c.Airport = NewAirportClient(c.config)
	c.Booking = NewBookingClient(c.config)
	c.BookingPassenger = NewBookingPassengerClient(c.config)
	c.Flight = NewFlightClient(c.config)
	c.FlightSeat = NewFlightSeatClient(c.config)
	c.Passenger = NewPassengerClient(c.config)
	c.Payment = NewPaymentClient(c.config)
	c.Seats = NewSeatsClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Aircraft:         NewAircraftClient(cfg),
		Airport:          NewAirportClient(cfg),
		Booking:          NewBookingClient(cfg),
		BookingPassenger: NewBookingPassengerClient(cfg),
		Flight:           NewFlightClient(cfg),
		FlightSeat:       NewFlightSeatClient(cfg),
		Passenger:        NewPassengerClient(cfg),
		Payment:          NewPaymentClient(cfg),
		Seats:            NewSeatsClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Aircraft:         NewAircraftClient(cfg),
		Airport:          NewAirportClient(cfg),
		Booking:          NewBookingClient(cfg),
		BookingPassenger: NewBookingPassengerClient(cfg),
		Flight:           NewFlightClient(cfg),
		FlightSeat:       NewFlightSeatClient(cfg),
		Passenger:        NewPassengerClient(cfg),
		Payment:          NewPaymentClient(cfg),
		Seats:            NewSeatsClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Aircraft.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Aircraft, c.Airport, c.Booking, c.BookingPassenger, c.Flight, c.FlightSeat,
		c.Passenger, c.Payment, c.Seats, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Aircraft, c.Airport, c.Booking, c.BookingPassenger, c.Flight, c.FlightSeat,
		c.Passenger, c.Payment, c.Seats, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AircraftMutation:
		return c.Aircraft.mutate(ctx, m)
	case *AirportMutation:
		return c.Airport.mutate(ctx, m)
	case *BookingMutation:
		return c.Booking.mutate(ctx, m)
	case *BookingPassengerMutation:
		return c.BookingPassenger.mutate(ctx, m)
	case *FlightMutation:
		return c.Flight.mutate(ctx, m)
	case *FlightSeatMutation:
		return c.FlightSeat.mutate(ctx, m)
	case *PassengerMutation:
		return c.Passenger.mutate(ctx, m)
	case *PaymentMutation:
		return c.Payment.mutate(ctx, m)
	case *SeatsMutation:
		return c.Seats.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AircraftClient is a client for the Aircraft schema.
type AircraftClient struct {
	config
}

// NewAircraftClient returns a client for the Aircraft from the given config.
func NewAircraftClient(c config) *AircraftClient {
	return &AircraftClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `aircraft.Hooks(f(g(h())))`.
func (c *AircraftClient) Use(hooks ...Hook) {
	c.hooks.Aircraft = append(c.hooks.Aircraft, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `aircraft.Intercept(f(g(h())))`.
func (c *AircraftClient) Intercept(interceptors ...Interceptor) {
	c.inters.Aircraft = append(c.inters.Aircraft, interceptors...)
}

// Create returns a builder for creating a Aircraft entity.
func (c *AircraftClient) Create() *AircraftCreate {
	mutation := newAircraftMutation(c.config, OpCreate)
	return &AircraftCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Aircraft entities.
func (c *AircraftClient) CreateBulk(builders ...*AircraftCreate) *AircraftCreateBulk {
	return &AircraftCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AircraftClient) MapCreateBulk(slice any, setFunc func(*AircraftCreate, int)) *AircraftCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AircraftCreateBulk{err: fmt.Errorf("calling to AircraftClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AircraftCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AircraftCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Aircraft.
func (c *AircraftClient) Update() *AircraftUpdate {
	mutation := newAircraftMutation(c.config, OpUpdate)
	return &AircraftUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AircraftClient) UpdateOne(_m *Aircraft) *AircraftUpdateOne {
	mutation := newAircraftMutation(c.config, OpUpdateOne, withAircraft(_m))
	return &AircraftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AircraftClient) UpdateOneID(id uuid.UUID) *AircraftUpdateOne {
	mutation := newAircraftMutation(c.config, OpUpdateOne, withAircraftID(id))
	return &AircraftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Aircraft.
func (c *AircraftClient) Delete() *AircraftDelete {
	mutation := newAircraftMutation(c.config, OpDelete)
	return &AircraftDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AircraftClient) DeleteOne(_m *Aircraft) *AircraftDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AircraftClient) DeleteOneID(id uuid.UUID) *AircraftDeleteOne {
	builder := c.Delete().Where(aircraft.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AircraftDeleteOne{builder}
}

// Query returns a query builder for Aircraft.
func (c *AircraftClient) Query() *AircraftQuery {
	return &AircraftQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAircraft},
		inters: c.Interceptors(),
	}
}

// Get returns a Aircraft entity by its id.
func (c *AircraftClient) Get(ctx context.Context, id uuid.UUID) (*Aircraft, error) {
	return c.Query().Where(aircraft.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AircraftClient) GetX(ctx context.Context, id uuid.UUID) *Aircraft {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFlights queries the flights edge of a Aircraft.
func (c *AircraftClient) QueryFlights(_m *Aircraft) *FlightQuery {
	query := (&FlightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(aircraft.Table, aircraft.FieldID, id),
			sqlgraph.To(flight.Table, flight.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, aircraft.FlightsTable, aircraft.FlightsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeats queries the seats edge of a Aircraft.
func (c *AircraftClient) QuerySeats(_m *Aircraft) *SeatsQuery {
	query := (&SeatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(aircraft.Table, aircraft.FieldID, id),
			sqlgraph.To(seats.Table, seats.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, aircraft.SeatsTable, aircraft.SeatsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AircraftClient) Hooks() []Hook {
	return c.hooks.Aircraft
}

// Interceptors returns the client interceptors.
func (c *AircraftClient) Interceptors() []Interceptor {
	return c.inters.Aircraft
}

func (c *AircraftClient) mutate(ctx context.Context, m *AircraftMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AircraftCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AircraftUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AircraftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AircraftDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Aircraft mutation op: %q", m.Op())
	}
}

// AirportClient is a client for the Airport schema.
type AirportClient struct {
	config
}

// NewAirportClient returns a client for the Airport from the given config.
func NewAirportClient(c config) *AirportClient {
	return &AirportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `airport.Hooks(f(g(h())))`.
func (c *AirportClient) Use(hooks ...Hook) {
	c.hooks.Airport = append(c.hooks.Airport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `airport.Intercept(f(g(h())))`.
func (c *AirportClient) Intercept(interceptors ...Interceptor) {
	c.inters.Airport = append(c.inters.Airport, interceptors...)
}

// Create returns a builder for creating a Airport entity.
func (c *AirportClient) Create() *AirportCreate {
	mutation := newAirportMutation(c.config, OpCreate)
	return &AirportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Airport entities.
func (c *AirportClient) CreateBulk(builders ...*AirportCreate) *AirportCreateBulk {
	return &AirportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AirportClient) MapCreateBulk(slice any, setFunc func(*AirportCreate, int)) *AirportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AirportCreateBulk{err: fmt.Errorf("calling to AirportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AirportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AirportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Airport.
func (c *AirportClient) Update() *AirportUpdate {
	mutation := newAirportMutation(c.config, OpUpdate)
	return &AirportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AirportClient) UpdateOne(_m *Airport) *AirportUpdateOne {
	mutation := newAirportMutation(c.config, OpUpdateOne, withAirport(_m))
	return &AirportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AirportClient) UpdateOneID(id uuid.UUID) *AirportUpdateOne {
	mutation := newAirportMutation(c.config, OpUpdateOne, withAirportID(id))
	return &AirportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Airport.
func (c *AirportClient) Delete() *AirportDelete {
	mutation := newAirportMutation(c.config, OpDelete)
	return &AirportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AirportClient) DeleteOne(_m *Airport) *AirportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AirportClient) DeleteOneID(id uuid.UUID) *AirportDeleteOne {
	builder := c.Delete().Where(airport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AirportDeleteOne{builder}
}

// Query returns a query builder for Airport.
func (c *AirportClient) Query() *AirportQuery {
	return &AirportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAirport},
		inters: c.Interceptors(),
	}
}

// Get returns a Airport entity by its id.
func (c *AirportClient) Get(ctx context.Context, id uuid.UUID) (*Airport, error) {
	return c.Query().Where(airport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AirportClient) GetX(ctx context.Context, id uuid.UUID) *Airport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDepartures queries the departures edge of a Airport.
func (c *AirportClient) QueryDepartures(_m *Airport) *FlightQuery {
	query := (&FlightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(flight.Table, flight.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, airport.DeparturesTable, airport.DeparturesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArrivals queries the arrivals edge of a Airport.
func (c *AirportClient) QueryArrivals(_m *Airport) *FlightQuery {
	query := (&FlightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(flight.Table, flight.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, airport.ArrivalsTable, airport.ArrivalsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AirportClient) Hooks() []Hook {
	return c.hooks.Airport
}

// Interceptors returns the client interceptors.
func (c *AirportClient) Interceptors() []Interceptor {
	return c.inters.Airport
}

func (c *AirportClient) mutate(ctx context.Context, m *AirportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AirportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AirportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AirportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AirportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Airport mutation op: %q", m.Op())
	}
}

// BookingClient is a client for the Booking schema.
type BookingClient struct {
	config
}

// NewBookingClient returns a client for the Booking from the given config.
func NewBookingClient(c config) *BookingClient {
	return &BookingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `booking.Hooks(f(g(h())))`.
func (c *BookingClient) Use(hooks ...Hook) {
	c.hooks.Booking = append(c.hooks.Booking, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `booking.Intercept(f(g(h())))`.
func (c *BookingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Booking = append(c.inters.Booking, interceptors...)
}

// Create returns a builder for creating a Booking entity.
func (c *BookingClient) Create() *BookingCreate {
	mutation := newBookingMutation(c.config, OpCreate)
	return &BookingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Booking entities.
func (c *BookingClient) CreateBulk(builders ...*BookingCreate) *BookingCreateBulk {
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookingClient) MapCreateBulk(slice any, setFunc func(*BookingCreate, int)) *BookingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookingCreateBulk{err: fmt.Errorf("calling to BookingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Booking.
func (c *BookingClient) Update() *BookingUpdate {
	mutation := newBookingMutation(c.config, OpUpdate)
	return &BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookingClient) UpdateOne(_m *Booking) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBooking(_m))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookingClient) UpdateOneID(id uuid.UUID) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBookingID(id))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Booking.
func (c *BookingClient) Delete() *BookingDelete {
	mutation := newBookingMutation(c.config, OpDelete)
	return &BookingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookingClient) DeleteOne(_m *Booking) *BookingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookingClient) DeleteOneID(id uuid.UUID) *BookingDeleteOne {
	builder := c.Delete().Where(booking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookingDeleteOne{builder}
}

// Query returns a query builder for Booking.
func (c *BookingClient) Query() *BookingQuery {
	return &BookingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBooking},
		inters: c.Interceptors(),
	}
}

// Get returns a Booking entity by its id.
func (c *BookingClient) Get(ctx context.Context, id uuid.UUID) (*Booking, error) {
	return c.Query().Where(booking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookingClient) GetX(ctx context.Context, id uuid.UUID) *Booking {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Booking.
func (c *BookingClient) QueryUser(_m *Booking) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.UserTable, booking.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlight queries the flight edge of a Booking.
func (c *BookingClient) QueryFlight(_m *Booking) *FlightQuery {
	query := (&FlightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(flight.Table, flight.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.FlightTable, booking.FlightColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookingPassengers queries the booking_passengers edge of a Booking.
func (c *BookingClient) QueryBookingPassengers(_m *Booking) *BookingPassengerQuery {
	query := (&BookingPassengerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(bookingpassenger.Table, bookingpassenger.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, booking.BookingPassengersTable, booking.BookingPassengersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayments queries the payments edge of a Booking.
func (c *BookingClient) QueryPayments(_m *Booking) *PaymentQuery {
	query := (&PaymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, booking.PaymentsTable, booking.PaymentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookingClient) Hooks() []Hook {
	return c.hooks.Booking
}

// Interceptors returns the client interceptors.
func (c *BookingClient) Interceptors() []Interceptor {
	return c.inters.Booking
}

func (c *BookingClient) mutate(ctx context.Context, m *BookingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Booking mutation op: %q", m.Op())
	}
}

// BookingPassengerClient is a client for the BookingPassenger schema.
type BookingPassengerClient struct {
	config
}

// NewBookingPassengerClient returns a client for the BookingPassenger from the given config.
func NewBookingPassengerClient(c config) *BookingPassengerClient {
	return &BookingPassengerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookingpassenger.Hooks(f(g(h())))`.
func (c *BookingPassengerClient) Use(hooks ...Hook) {
	c.hooks.BookingPassenger = append(c.hooks.BookingPassenger, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookingpassenger.Intercept(f(g(h())))`.
func (c *BookingPassengerClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookingPassenger = append(c.inters.BookingPassenger, interceptors...)
}

// Create returns a builder for creating a BookingPassenger entity.
func (c *BookingPassengerClient) Create() *BookingPassengerCreate {
	mutation := newBookingPassengerMutation(c.config, OpCreate)
	return &BookingPassengerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookingPassenger entities.
func (c *BookingPassengerClient) CreateBulk(builders ...*BookingPassengerCreate) *BookingPassengerCreateBulk {
	return &BookingPassengerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookingPassengerClient) MapCreateBulk(slice any, setFunc func(*BookingPassengerCreate, int)) *BookingPassengerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookingPassengerCreateBulk{err: fmt.Errorf("calling to BookingPassengerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookingPassengerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookingPassengerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookingPassenger.
func (c *BookingPassengerClient) Update() *BookingPassengerUpdate {
	mutation := newBookingPassengerMutation(c.config, OpUpdate)
	return &BookingPassengerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookingPassengerClient) UpdateOne(_m *BookingPassenger) *BookingPassengerUpdateOne {
	mutation := newBookingPassengerMutation(c.config, OpUpdateOne, withBookingPassenger(_m))
	return &BookingPassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookingPassengerClient) UpdateOneID(id uuid.UUID) *BookingPassengerUpdateOne {
	mutation := newBookingPassengerMutation(c.config, OpUpdateOne, withBookingPassengerID(id))
	return &BookingPassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookingPassenger.
func (c *BookingPassengerClient) Delete() *BookingPassengerDelete {
	mutation := newBookingPassengerMutation(c.config, OpDelete)
	return &BookingPassengerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookingPassengerClient) DeleteOne(_m *BookingPassenger) *BookingPassengerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookingPassengerClient) DeleteOneID(id uuid.UUID) *BookingPassengerDeleteOne {
	builder := c.Delete().Where(bookingpassenger.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookingPassengerDeleteOne{builder}
}

// Query returns a query builder for BookingPassenger.
func (c *BookingPassengerClient) Query() *BookingPassengerQuery {
	return &BookingPassengerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookingPassenger},
		inters: c.Interceptors(),
	}
}

// Get returns a BookingPassenger entity by its id.
func (c *BookingPassengerClient) Get(ctx context.Context, id uuid.UUID) (*BookingPassenger, error) {
	return c.Query().Where(bookingpassenger.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookingPassengerClient) GetX(ctx context.Context, id uuid.UUID) *BookingPassenger {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooking queries the booking edge of a BookingPassenger.
func (c *BookingPassengerClient) QueryBooking(_m *BookingPassenger) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookingpassenger.Table, bookingpassenger.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bookingpassenger.BookingTable, bookingpassenger.BookingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPassenger queries the passenger edge of a BookingPassenger.
func (c *BookingPassengerClient) QueryPassenger(_m *BookingPassenger) *PassengerQuery {
	query := (&PassengerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookingpassenger.Table, bookingpassenger.FieldID, id),
			sqlgraph.To(passenger.Table, passenger.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bookingpassenger.PassengerTable, bookingpassenger.PassengerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlightSeat queries the flight_seat edge of a BookingPassenger.
func (c *BookingPassengerClient) QueryFlightSeat(_m *BookingPassenger) *FlightSeatQuery {
	query := (&FlightSeatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookingpassenger.Table, bookingpassenger.FieldID, id),
			sqlgraph.To(flightseat.Table, flightseat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bookingpassenger.FlightSeatTable, bookingpassenger.FlightSeatColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookingPassengerClient) Hooks() []Hook {
	return c.hooks.BookingPassenger
}

// Interceptors returns the client interceptors.
func (c *BookingPassengerClient) Interceptors() []Interceptor {
	return c.inters.BookingPassenger
}

func (c *BookingPassengerClient) mutate(ctx context.Context, m *BookingPassengerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookingPassengerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookingPassengerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookingPassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookingPassengerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookingPassenger mutation op: %q", m.Op())
	}
}

// FlightClient is a client for the Flight schema.
type FlightClient struct {
	config
}

// NewFlightClient returns a client for the Flight from the given config.
func NewFlightClient(c config) *FlightClient {
	return &FlightClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `flight.Hooks(f(g(h())))`.
func (c *FlightClient) Use(hooks ...Hook) {
	c.hooks.Flight = append(c.hooks.Flight, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `flight.Intercept(f(g(h())))`.
func (c *FlightClient) Intercept(interceptors ...Interceptor) {
	c.inters.Flight = append(c.inters.Flight, interceptors...)
}

// Create returns a builder for creating a Flight entity.
func (c *FlightClient) Create() *FlightCreate {
	mutation := newFlightMutation(c.config, OpCreate)
	return &FlightCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Flight entities.
func (c *FlightClient) CreateBulk(builders ...*FlightCreate) *FlightCreateBulk {
	return &FlightCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FlightClient) MapCreateBulk(slice any, setFunc func(*FlightCreate, int)) *FlightCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FlightCreateBulk{err: fmt.Errorf("calling to FlightClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FlightCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FlightCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Flight.
func (c *FlightClient) Update() *FlightUpdate {
	mutation := newFlightMutation(c.config, OpUpdate)
	return &FlightUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FlightClient) UpdateOne(_m *Flight) *FlightUpdateOne {
	mutation := newFlightMutation(c.config, OpUpdateOne, withFlight(_m))
	return &FlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FlightClient) UpdateOneID(id uuid.UUID) *FlightUpdateOne {
	mutation := newFlightMutation(c.config, OpUpdateOne, withFlightID(id))
	return &FlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Flight.
func (c *FlightClient) Delete() *FlightDelete {
	mutation := newFlightMutation(c.config, OpDelete)
	return &FlightDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FlightClient) DeleteOne(_m *Flight) *FlightDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FlightClient) DeleteOneID(id uuid.UUID) *FlightDeleteOne {
	builder := c.Delete().Where(flight.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FlightDeleteOne{builder}
}

// Query returns a query builder for Flight.
func (c *FlightClient) Query() *FlightQuery {
	return &FlightQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFlight},
		inters: c.Interceptors(),
	}
}

// Get returns a Flight entity by its id.
func (c *FlightClient) Get(ctx context.Context, id uuid.UUID) (*Flight, error) {
	return c.Query().Where(flight.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FlightClient) GetX(ctx context.Context, id uuid.UUID) *Flight {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAircraft queries the aircraft edge of a Flight.
func (c *FlightClient) QueryAircraft(_m *Flight) *AircraftQuery {
	query := (&AircraftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flight.Table, flight.FieldID, id),
			sqlgraph.To(aircraft.Table, aircraft.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flight.AircraftTable, flight.AircraftColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartureAirport queries the departure_airport edge of a Flight.
func (c *FlightClient) QueryDepartureAirport(_m *Flight) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flight.Table, flight.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flight.DepartureAirportTable, flight.DepartureAirportColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArrivalAirport queries the arrival_airport edge of a Flight.
func (c *FlightClient) QueryArrivalAirport(_m *Flight) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flight.Table, flight.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flight.ArrivalAirportTable, flight.ArrivalAirportColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlightSeats queries the flight_seats edge of a Flight.
func (c *FlightClient) QueryFlightSeats(_m *Flight) *FlightSeatQuery {
	query := (&FlightSeatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flight.Table, flight.FieldID, id),
			sqlgraph.To(flightseat.Table, flightseat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, flight.FlightSeatsTable, flight.FlightSeatsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Flight.
func (c *FlightClient) QueryBookings(_m *Flight) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flight.Table, flight.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, flight.BookingsTable, flight.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FlightClient) Hooks() []Hook {
	return c.hooks.Flight
}

// Interceptors returns the client interceptors.
func (c *FlightClient) Interceptors() []Interceptor {
	return c.inters.Flight
}

func (c *FlightClient) mutate(ctx context.Context, m *FlightMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FlightCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FlightUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FlightDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Flight mutation op: %q", m.Op())
	}
}

// FlightSeatClient is a client for the FlightSeat schema.
type FlightSeatClient struct {
	config
}

// NewFlightSeatClient returns a client for the FlightSeat from the given config.
func NewFlightSeatClient(c config) *FlightSeatClient {
	return &FlightSeatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `flightseat.Hooks(f(g(h())))`.
func (c *FlightSeatClient) Use(hooks ...Hook) {
	c.hooks.FlightSeat = append(c.hooks.FlightSeat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `flightseat.Intercept(f(g(h())))`.
func (c *FlightSeatClient) Intercept(interceptors ...Interceptor) {
	c.inters.FlightSeat = append(c.inters.FlightSeat, interceptors...)
}

// Create returns a builder for creating a FlightSeat entity.
func (c *FlightSeatClient) Create() *FlightSeatCreate {
	mutation := newFlightSeatMutation(c.config, OpCreate)
	return &FlightSeatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FlightSeat entities.
func (c *FlightSeatClient) CreateBulk(builders ...*FlightSeatCreate) *FlightSeatCreateBulk {
	return &FlightSeatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FlightSeatClient) MapCreateBulk(slice any, setFunc func(*FlightSeatCreate, int)) *FlightSeatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FlightSeatCreateBulk{err: fmt.Errorf("calling to FlightSeatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FlightSeatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FlightSeatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FlightSeat.
func (c *FlightSeatClient) Update() *FlightSeatUpdate {
	mutation := newFlightSeatMutation(c.config, OpUpdate)
	return &FlightSeatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FlightSeatClient) UpdateOne(_m *FlightSeat) *FlightSeatUpdateOne {
	mutation := newFlightSeatMutation(c.config, OpUpdateOne, withFlightSeat(_m))
	return &FlightSeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FlightSeatClient) UpdateOneID(id uuid.UUID) *FlightSeatUpdateOne {
	mutation := newFlightSeatMutation(c.config, OpUpdateOne, withFlightSeatID(id))
	return &FlightSeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FlightSeat.
func (c *FlightSeatClient) Delete() *FlightSeatDelete {
	mutation := newFlightSeatMutation(c.config, OpDelete)
	return &FlightSeatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FlightSeatClient) DeleteOne(_m *FlightSeat) *FlightSeatDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FlightSeatClient) DeleteOneID(id uuid.UUID) *FlightSeatDeleteOne {
	builder := c.Delete().Where(flightseat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FlightSeatDeleteOne{builder}
}

// Query returns a query builder for FlightSeat.
func (c *FlightSeatClient) Query() *FlightSeatQuery {
	return &FlightSeatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFlightSeat},
		inters: c.Interceptors(),
	}
}

// Get returns a FlightSeat entity by its id.
func (c *FlightSeatClient) Get(ctx context.Context, id uuid.UUID) (*FlightSeat, error) {
	return c.Query().Where(flightseat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FlightSeatClient) GetX(ctx context.Context, id uuid.UUID) *FlightSeat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFlight queries the flight edge of a FlightSeat.
func (c *FlightSeatClient) QueryFlight(_m *FlightSeat) *FlightQuery {
	query := (&FlightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flightseat.Table, flightseat.FieldID, id),
			sqlgraph.To(flight.Table, flight.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flightseat.FlightTable, flightseat.FlightColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeat queries the seat edge of a FlightSeat.
func (c *FlightSeatClient) QuerySeat(_m *FlightSeat) *SeatsQuery {
	query := (&SeatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flightseat.Table, flightseat.FieldID, id),
			sqlgraph.To(seats.Table, seats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flightseat.SeatTable, flightseat.SeatColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssigned queries the assigned edge of a FlightSeat.
func (c *FlightSeatClient) QueryAssigned(_m *FlightSeat) *BookingPassengerQuery {
	query := (&BookingPassengerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flightseat.Table, flightseat.FieldID, id),
			sqlgraph.To(bookingpassenger.Table, bookingpassenger.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, flightseat.AssignedTable, flightseat.AssignedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FlightSeatClient) Hooks() []Hook {
	return c.hooks.FlightSeat
}

// Interceptors returns the client interceptors.
func (c *FlightSeatClient) Interceptors() []Interceptor {
	return c.inters.FlightSeat
}

func (c *FlightSeatClient) mutate(ctx context.Context, m *FlightSeatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FlightSeatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FlightSeatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FlightSeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FlightSeatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FlightSeat mutation op: %q", m.Op())
	}
}

// PassengerClient is a client for the Passenger schema.
type PassengerClient struct {
	config
}

// NewPassengerClient returns a client for the Passenger from the given config.
func NewPassengerClient(c config) *PassengerClient {
	return &PassengerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passenger.Hooks(f(g(h())))`.
func (c *PassengerClient) Use(hooks ...Hook) {
	c.hooks.Passenger = append(c.hooks.Passenger, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passenger.Intercept(f(g(h())))`.
func (c *PassengerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Passenger = append(c.inters.Passenger, interceptors...)
}

// Create returns a builder for creating a Passenger entity.
func (c *PassengerClient) Create() *PassengerCreate {
	mutation := newPassengerMutation(c.config, OpCreate)
	return &PassengerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Passenger entities.
func (c *PassengerClient) CreateBulk(builders ...*PassengerCreate) *PassengerCreateBulk {
	return &PassengerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PassengerClient) MapCreateBulk(slice any, setFunc func(*PassengerCreate, int)) *PassengerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PassengerCreateBulk{err: fmt.Errorf("calling to PassengerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PassengerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PassengerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Passenger.
func (c *PassengerClient) Update() *PassengerUpdate {
	mutation := newPassengerMutation(c.config, OpUpdate)
	return &PassengerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PassengerClient) UpdateOne(_m *Passenger) *PassengerUpdateOne {
	mutation := newPassengerMutation(c.config, OpUpdateOne, withPassenger(_m))
	return &PassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PassengerClient) UpdateOneID(id uuid.UUID) *PassengerUpdateOne {
	mutation := newPassengerMutation(c.config, OpUpdateOne, withPassengerID(id))
	return &PassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Passenger.
func (c *PassengerClient) Delete() *PassengerDelete {
	mutation := newPassengerMutation(c.config, OpDelete)
	return &PassengerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PassengerClient) DeleteOne(_m *Passenger) *PassengerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PassengerClient) DeleteOneID(id uuid.UUID) *PassengerDeleteOne {
	builder := c.Delete().Where(passenger.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PassengerDeleteOne{builder}
}

// Query returns a query builder for Passenger.
func (c *PassengerClient) Query() *PassengerQuery {
	return &PassengerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePassenger},
		inters: c.Interceptors(),
	}
}

// Get returns a Passenger entity by its id.
func (c *PassengerClient) Get(ctx context.Context, id uuid.UUID) (*Passenger, error) {
	return c.Query().Where(passenger.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PassengerClient) GetX(ctx context.Context, id uuid.UUID) *Passenger {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBookingEntries queries the booking_entries edge of a Passenger.
func (c *PassengerClient) QueryBookingEntries(_m *Passenger) *BookingPassengerQuery {
	query := (&BookingPassengerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passenger.Table, passenger.FieldID, id),
			sqlgraph.To(bookingpassenger.Table, bookingpassenger.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, passenger.BookingEntriesTable, passenger.BookingEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PassengerClient) Hooks() []Hook {
	return c.hooks.Passenger
}

// Interceptors returns the client interceptors.
func (c *PassengerClient) Interceptors() []Interceptor {
	return c.inters.Passenger
}

func (c *PassengerClient) mutate(ctx context.Context, m *PassengerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PassengerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PassengerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PassengerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Passenger mutation op: %q", m.Op())
	}
}

// PaymentClient is a client for the Payment schema.
type PaymentClient struct {
	config
}

// NewPaymentClient returns a client for the Payment from the given config.
func NewPaymentClient(c config) *PaymentClient {
	return &PaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payment.Hooks(f(g(h())))`.
func (c *PaymentClient) Use(hooks ...Hook) {
	c.hooks.Payment = append(c.hooks.Payment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payment.Intercept(f(g(h())))`.
func (c *PaymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payment = append(c.inters.Payment, interceptors...)
}

// Create returns a builder for creating a Payment entity.
func (c *PaymentClient) Create() *PaymentCreate {
	mutation := newPaymentMutation(c.config, OpCreate)
	return &PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payment entities.
func (c *PaymentClient) CreateBulk(builders ...*PaymentCreate) *PaymentCreateBulk {
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentClient) MapCreateBulk(slice any, setFunc func(*PaymentCreate, int)) *PaymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentCreateBulk{err: fmt.Errorf("calling to PaymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payment.
func (c *PaymentClient) Update() *PaymentUpdate {
	mutation := newPaymentMutation(c.config, OpUpdate)
	return &PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentClient) UpdateOne(_m *Payment) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPayment(_m))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentClient) UpdateOneID(id uuid.UUID) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPaymentID(id))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payment.
func (c *PaymentClient) Delete() *PaymentDelete {
	mutation := newPaymentMutation(c.config, OpDelete)
	return &PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentClient) DeleteOne(_m *Payment) *PaymentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentClient) DeleteOneID(id uuid.UUID) *PaymentDeleteOne {
	builder := c.Delete().Where(payment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentDeleteOne{builder}
}

// Query returns a query builder for Payment.
func (c *PaymentClient) Query() *PaymentQuery {
	return &PaymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayment},
		inters: c.Interceptors(),
	}
}

// Get returns a Payment entity by its id.
func (c *PaymentClient) Get(ctx context.Context, id uuid.UUID) (*Payment, error) {
	return c.Query().Where(payment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentClient) GetX(ctx context.Context, id uuid.UUID) *Payment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooking queries the booking edge of a Payment.
func (c *PaymentClient) QueryBooking(_m *Payment) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.BookingTable, payment.BookingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PaymentClient) Hooks() []Hook {
	return c.hooks.Payment
}

// Interceptors returns the client interceptors.
func (c *PaymentClient) Interceptors() []Interceptor {
	return c.inters.Payment
}

func (c *PaymentClient) mutate(ctx context.Context, m *PaymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Payment mutation op: %q", m.Op())
	}
}

// SeatsClient is a client for the Seats schema.
type SeatsClient struct {
	config
}

// NewSeatsClient returns a client for the Seats from the given config.
func NewSeatsClient(c config) *SeatsClient {
	return &SeatsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seats.Hooks(f(g(h())))`.
func (c *SeatsClient) Use(hooks ...Hook) {
	c.hooks.Seats = append(c.hooks.Seats, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seats.Intercept(f(g(h())))`.
func (c *SeatsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Seats = append(c.inters.Seats, interceptors...)
}

// Create returns a builder for creating a Seats entity.
func (c *SeatsClient) Create() *SeatsCreate {
	mutation := newSeatsMutation(c.config, OpCreate)
	return &SeatsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Seats entities.
func (c *SeatsClient) CreateBulk(builders ...*SeatsCreate) *SeatsCreateBulk {
	return &SeatsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeatsClient) MapCreateBulk(slice any, setFunc func(*SeatsCreate, int)) *SeatsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeatsCreateBulk{err: fmt.Errorf("calling to SeatsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeatsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeatsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Seats.
func (c *SeatsClient) Update() *SeatsUpdate {
	mutation := newSeatsMutation(c.config, OpUpdate)
	return &SeatsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeatsClient) UpdateOne(_m *Seats) *SeatsUpdateOne {
	mutation := newSeatsMutation(c.config, OpUpdateOne, withSeats(_m))
	return &SeatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeatsClient) UpdateOneID(id uuid.UUID) *SeatsUpdateOne {
	mutation := newSeatsMutation(c.config, OpUpdateOne, withSeatsID(id))
	return &SeatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Seats.
func (c *SeatsClient) Delete() *SeatsDelete {
	mutation := newSeatsMutation(c.config, OpDelete)
	return &SeatsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeatsClient) DeleteOne(_m *Seats) *SeatsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeatsClient) DeleteOneID(id uuid.UUID) *SeatsDeleteOne {
	builder := c.Delete().Where(seats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeatsDeleteOne{builder}
}

// Query returns a query builder for Seats.
func (c *SeatsClient) Query() *SeatsQuery {
	return &SeatsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeats},
		inters: c.Interceptors(),
	}
}

// Get returns a Seats entity by its id.
func (c *SeatsClient) Get(ctx context.Context, id uuid.UUID) (*Seats, error) {
	return c.Query().Where(seats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeatsClient) GetX(ctx context.Context, id uuid.UUID) *Seats {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAircraft queries the aircraft edge of a Seats.
func (c *SeatsClient) QueryAircraft(_m *Seats) *AircraftQuery {
	query := (&AircraftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seats.Table, seats.FieldID, id),
			sqlgraph.To(aircraft.Table, aircraft.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seats.AircraftTable, seats.AircraftColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlightInstances queries the flight_instances edge of a Seats.
func (c *SeatsClient) QueryFlightInstances(_m *Seats) *FlightSeatQuery {
	query := (&FlightSeatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seats.Table, seats.FieldID, id),
			sqlgraph.To(flightseat.Table, flightseat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, seats.FlightInstancesTable, seats.FlightInstancesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeatsClient) Hooks() []Hook {
	return c.hooks.Seats
}

// Interceptors returns the client interceptors.
func (c *SeatsClient) Interceptors() []Interceptor {
	return c.inters.Seats
}

func (c *SeatsClient) mutate(ctx context.Context, m *SeatsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeatsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeatsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeatsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Seats mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBookings queries the bookings edge of a User.
func (c *UserClient) QueryBookings(_m *User) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BookingsTable, user.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Aircraft, Airport, Booking, BookingPassenger, Flight, FlightSeat, Passenger,
		Payment, Seats, User []ent.Hook
	}
	inters struct {
		Aircraft, Airport, Booking, BookingPassenger, Flight, FlightSeat, Passenger,
		Payment, Seats, User []ent.Interceptor
	}
)

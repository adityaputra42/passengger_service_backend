// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"pasengger_service/ent/aircraft"
	"pasengger_service/ent/airport"
	"pasengger_service/ent/booking"
	"pasengger_service/ent/bookingpassenger"
	"pasengger_service/ent/flight"
	"pasengger_service/ent/flightseat"
	"pasengger_service/ent/passenger"
	"pasengger_service/ent/payment"
	"pasengger_service/ent/predicate"
	"pasengger_service/ent/seats"
	"pasengger_service/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAircraft         = "Aircraft"
	TypeAirport          = "Airport"
	TypeBooking          = "Booking"
	TypeBookingPassenger = "BookingPassenger"
	TypeFlight           = "Flight"
	TypeFlightSeat       = "FlightSeat"
	TypePassenger        = "Passenger"
	TypePayment          = "Payment"
	TypeSeats            = "Seats"
	TypeUser             = "User"
)

// AircraftMutation represents an operation that mutates the Aircraft nodes in the graph.
type AircraftMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	model           *string
	registration_no *string
	total_seats     *int
	addtotal_seats  *int
	created_at      *time.Time
	clearedFields   map[string]struct{}
	flights         map[uuid.UUID]struct{}
	removedflights  map[uuid.UUID]struct{}
	clearedflights  bool
	seats           map[uuid.UUID]struct{}
	removedseats    map[uuid.UUID]struct{}
	clearedseats    bool
	done            bool
	oldValue        func(context.Context) (*Aircraft, error)
	predicates      []predicate.Aircraft
}

var _ ent.Mutation = (*AircraftMutation)(nil)

// aircraftOption allows management of the mutation configuration using functional options.
type aircraftOption func(*AircraftMutation)

// newAircraftMutation creates new mutation for the Aircraft entity.
func newAircraftMutation(c config, op Op, opts ...aircraftOption) *AircraftMutation {
	m := &AircraftMutation{
		config:        c,
		op:            op,
		typ:           TypeAircraft,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAircraftID sets the ID field of the mutation.
func withAircraftID(id uuid.UUID) aircraftOption {
	return func(m *AircraftMutation) {
		var (
			err   error
			once  sync.Once
			value *Aircraft
		)
		m.oldValue = func(ctx context.Context) (*Aircraft, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Aircraft.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAircraft sets the old Aircraft of the mutation.
func withAircraft(node *Aircraft) aircraftOption {
	return func(m *AircraftMutation) {
		m.oldValue = func(context.Context) (*Aircraft, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AircraftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AircraftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Aircraft entities.
func (m *AircraftMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AircraftMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AircraftMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Aircraft.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModel sets the "model" field.
func (m *AircraftMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *AircraftMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *AircraftMutation) ResetModel() {
	m.model = nil
}

// SetRegistrationNo sets the "registration_no" field.
func (m *AircraftMutation) SetRegistrationNo(s string) {
	m.registration_no = &s
}

// RegistrationNo returns the value of the "registration_no" field in the mutation.
func (m *AircraftMutation) RegistrationNo() (r string, exists bool) {
	v := m.registration_no
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationNo returns the old "registration_no" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldRegistrationNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationNo: %w", err)
	}
	return oldValue.RegistrationNo, nil
}

// ResetRegistrationNo resets all changes to the "registration_no" field.
func (m *AircraftMutation) ResetRegistrationNo() {
	m.registration_no = nil
}

// SetTotalSeats sets the "total_seats" field.
func (m *AircraftMutation) SetTotalSeats(i int) {
	m.total_seats = &i
	m.addtotal_seats = nil
}

// TotalSeats returns the value of the "total_seats" field in the mutation.
func (m *AircraftMutation) TotalSeats() (r int, exists bool) {
	v := m.total_seats
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSeats returns the old "total_seats" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldTotalSeats(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSeats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSeats: %w", err)
	}
	return oldValue.TotalSeats, nil
}

// AddTotalSeats adds i to the "total_seats" field.
func (m *AircraftMutation) AddTotalSeats(i int) {
	if m.addtotal_seats != nil {
		*m.addtotal_seats += i
	} else {
		m.addtotal_seats = &i
	}
}

// AddedTotalSeats returns the value that was added to the "total_seats" field in this mutation.
func (m *AircraftMutation) AddedTotalSeats() (r int, exists bool) {
	v := m.addtotal_seats
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSeats resets all changes to the "total_seats" field.
func (m *AircraftMutation) ResetTotalSeats() {
	m.total_seats = nil
	m.addtotal_seats = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AircraftMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AircraftMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AircraftMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddFlightIDs adds the "flights" edge to the Flight entity by ids.
func (m *AircraftMutation) AddFlightIDs(ids ...uuid.UUID) {
	if m.flights == nil {
		m.flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flights[ids[i]] = struct{}{}
	}
}

// ClearFlights clears the "flights" edge to the Flight entity.
func (m *AircraftMutation) ClearFlights() {
	m.clearedflights = true
}

// FlightsCleared reports if the "flights" edge to the Flight entity was cleared.
func (m *AircraftMutation) FlightsCleared() bool {
	return m.clearedflights
}

// RemoveFlightIDs removes the "flights" edge to the Flight entity by IDs.
func (m *AircraftMutation) RemoveFlightIDs(ids ...uuid.UUID) {
	if m.removedflights == nil {
		m.removedflights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flights, ids[i])
		m.removedflights[ids[i]] = struct{}{}
	}
}

// RemovedFlights returns the removed IDs of the "flights" edge to the Flight entity.
func (m *AircraftMutation) RemovedFlightsIDs() (ids []uuid.UUID) {
	for id := range m.removedflights {
		ids = append(ids, id)
	}
	return
}

// FlightsIDs returns the "flights" edge IDs in the mutation.
func (m *AircraftMutation) FlightsIDs() (ids []uuid.UUID) {
	for id := range m.flights {
		ids = append(ids, id)
	}
	return
}

// ResetFlights resets all changes to the "flights" edge.
func (m *AircraftMutation) ResetFlights() {
	m.flights = nil
	m.clearedflights = false
	m.removedflights = nil
}

// AddSeatIDs adds the "seats" edge to the Seats entity by ids.
func (m *AircraftMutation) AddSeatIDs(ids ...uuid.UUID) {
	if m.seats == nil {
		m.seats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.seats[ids[i]] = struct{}{}
	}
}

// ClearSeats clears the "seats" edge to the Seats entity.
func (m *AircraftMutation) ClearSeats() {
	m.clearedseats = true
}

// SeatsCleared reports if the "seats" edge to the Seats entity was cleared.
func (m *AircraftMutation) SeatsCleared() bool {
	return m.clearedseats
}

// RemoveSeatIDs removes the "seats" edge to the Seats entity by IDs.
func (m *AircraftMutation) RemoveSeatIDs(ids ...uuid.UUID) {
	if m.removedseats == nil {
		m.removedseats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.seats, ids[i])
		m.removedseats[ids[i]] = struct{}{}
	}
}

// RemovedSeats returns the removed IDs of the "seats" edge to the Seats entity.
func (m *AircraftMutation) RemovedSeatsIDs() (ids []uuid.UUID) {
	for id := range m.removedseats {
		ids = append(ids, id)
	}
	return
}

// SeatsIDs returns the "seats" edge IDs in the mutation.
func (m *AircraftMutation) SeatsIDs() (ids []uuid.UUID) {
	for id := range m.seats {
		ids = append(ids, id)
	}
	return
}

// ResetSeats resets all changes to the "seats" edge.
func (m *AircraftMutation) ResetSeats() {
	m.seats = nil
	m.clearedseats = false
	m.removedseats = nil
}

// Where appends a list predicates to the AircraftMutation builder.
func (m *AircraftMutation) Where(ps ...predicate.Aircraft) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AircraftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AircraftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Aircraft, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AircraftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AircraftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Aircraft).
func (m *AircraftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AircraftMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.model != nil {
		fields = append(fields, aircraft.FieldModel)
	}
	if m.registration_no != nil {
		fields = append(fields, aircraft.FieldRegistrationNo)
	}
	if m.total_seats != nil {
		fields = append(fields, aircraft.FieldTotalSeats)
	}
	if m.created_at != nil {
		fields = append(fields, aircraft.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AircraftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aircraft.FieldModel:
		return m.Model()
	case aircraft.FieldRegistrationNo:
		return m.RegistrationNo()
	case aircraft.FieldTotalSeats:
		return m.TotalSeats()
	case aircraft.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AircraftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aircraft.FieldModel:
		return m.OldModel(ctx)
	case aircraft.FieldRegistrationNo:
		return m.OldRegistrationNo(ctx)
	case aircraft.FieldTotalSeats:
		return m.OldTotalSeats(ctx)
	case aircraft.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Aircraft field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AircraftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aircraft.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case aircraft.FieldRegistrationNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationNo(v)
		return nil
	case aircraft.FieldTotalSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSeats(v)
		return nil
	case aircraft.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Aircraft field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AircraftMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_seats != nil {
		fields = append(fields, aircraft.FieldTotalSeats)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AircraftMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case aircraft.FieldTotalSeats:
		return m.AddedTotalSeats()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AircraftMutation) AddField(name string, value ent.Value) error {
	switch name {
	case aircraft.FieldTotalSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSeats(v)
		return nil
	}
	return fmt.Errorf("unknown Aircraft numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AircraftMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AircraftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AircraftMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Aircraft nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AircraftMutation) ResetField(name string) error {
	switch name {
	case aircraft.FieldModel:
		m.ResetModel()
		return nil
	case aircraft.FieldRegistrationNo:
		m.ResetRegistrationNo()
		return nil
	case aircraft.FieldTotalSeats:
		m.ResetTotalSeats()
		return nil
	case aircraft.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Aircraft field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AircraftMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.flights != nil {
		edges = append(edges, aircraft.EdgeFlights)
	}
	if m.seats != nil {
		edges = append(edges, aircraft.EdgeSeats)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AircraftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case aircraft.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.flights))
		for id := range m.flights {
			ids = append(ids, id)
		}
		return ids
	case aircraft.EdgeSeats:
		ids := make([]ent.Value, 0, len(m.seats))
		for id := range m.seats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AircraftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflights != nil {
		edges = append(edges, aircraft.EdgeFlights)
	}
	if m.removedseats != nil {
		edges = append(edges, aircraft.EdgeSeats)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AircraftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case aircraft.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.removedflights))
		for id := range m.removedflights {
			ids = append(ids, id)
		}
		return ids
	case aircraft.EdgeSeats:
		ids := make([]ent.Value, 0, len(m.removedseats))
		for id := range m.removedseats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AircraftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedflights {
		edges = append(edges, aircraft.EdgeFlights)
	}
	if m.clearedseats {
		edges = append(edges, aircraft.EdgeSeats)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AircraftMutation) EdgeCleared(name string) bool {
	switch name {
	case aircraft.EdgeFlights:
		return m.clearedflights
	case aircraft.EdgeSeats:
		return m.clearedseats
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AircraftMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Aircraft unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AircraftMutation) ResetEdge(name string) error {
	switch name {
	case aircraft.EdgeFlights:
		m.ResetFlights()
		return nil
	case aircraft.EdgeSeats:
		m.ResetSeats()
		return nil
	}
	return fmt.Errorf("unknown Aircraft edge %s", name)
}

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	code              *string
	name              *string
	city              *string
	country           *string
	created_at        *time.Time
	clearedFields     map[string]struct{}
	departures        map[uuid.UUID]struct{}
	removeddepartures map[uuid.UUID]struct{}
	cleareddepartures bool
	arrivals          map[uuid.UUID]struct{}
	removedarrivals   map[uuid.UUID]struct{}
	clearedarrivals   bool
	done              bool
	oldValue          func(context.Context) (*Airport, error)
	predicates        []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id uuid.UUID) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Airport entities.
func (m *AirportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *AirportMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AirportMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AirportMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetCity sets the "city" field.
func (m *AirportMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AirportMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AirportMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *AirportMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AirportMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AirportMutation) ResetCountry() {
	m.country = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AirportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AirportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AirportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddDepartureIDs adds the "departures" edge to the Flight entity by ids.
func (m *AirportMutation) AddDepartureIDs(ids ...uuid.UUID) {
	if m.departures == nil {
		m.departures = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.departures[ids[i]] = struct{}{}
	}
}

// ClearDepartures clears the "departures" edge to the Flight entity.
func (m *AirportMutation) ClearDepartures() {
	m.cleareddepartures = true
}

// DeparturesCleared reports if the "departures" edge to the Flight entity was cleared.
func (m *AirportMutation) DeparturesCleared() bool {
	return m.cleareddepartures
}

// RemoveDepartureIDs removes the "departures" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveDepartureIDs(ids ...uuid.UUID) {
	if m.removeddepartures == nil {
		m.removeddepartures = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.departures, ids[i])
		m.removeddepartures[ids[i]] = struct{}{}
	}
}

// RemovedDepartures returns the removed IDs of the "departures" edge to the Flight entity.
func (m *AirportMutation) RemovedDeparturesIDs() (ids []uuid.UUID) {
	for id := range m.removeddepartures {
		ids = append(ids, id)
	}
	return
}

// DeparturesIDs returns the "departures" edge IDs in the mutation.
func (m *AirportMutation) DeparturesIDs() (ids []uuid.UUID) {
	for id := range m.departures {
		ids = append(ids, id)
	}
	return
}

// ResetDepartures resets all changes to the "departures" edge.
func (m *AirportMutation) ResetDepartures() {
	m.departures = nil
	m.cleareddepartures = false
	m.removeddepartures = nil
}

// AddArrivalIDs adds the "arrivals" edge to the Flight entity by ids.
func (m *AirportMutation) AddArrivalIDs(ids ...uuid.UUID) {
	if m.arrivals == nil {
		m.arrivals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.arrivals[ids[i]] = struct{}{}
	}
}

// ClearArrivals clears the "arrivals" edge to the Flight entity.
func (m *AirportMutation) ClearArrivals() {
	m.clearedarrivals = true
}

// ArrivalsCleared reports if the "arrivals" edge to the Flight entity was cleared.
func (m *AirportMutation) ArrivalsCleared() bool {
	return m.clearedarrivals
}

// RemoveArrivalIDs removes the "arrivals" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveArrivalIDs(ids ...uuid.UUID) {
	if m.removedarrivals == nil {
		m.removedarrivals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.arrivals, ids[i])
		m.removedarrivals[ids[i]] = struct{}{}
	}
}

// RemovedArrivals returns the removed IDs of the "arrivals" edge to the Flight entity.
func (m *AirportMutation) RemovedArrivalsIDs() (ids []uuid.UUID) {
	for id := range m.removedarrivals {
		ids = append(ids, id)
	}
	return
}

// ArrivalsIDs returns the "arrivals" edge IDs in the mutation.
func (m *AirportMutation) ArrivalsIDs() (ids []uuid.UUID) {
	for id := range m.arrivals {
		ids = append(ids, id)
	}
	return
}

// ResetArrivals resets all changes to the "arrivals" edge.
func (m *AirportMutation) ResetArrivals() {
	m.arrivals = nil
	m.clearedarrivals = false
	m.removedarrivals = nil
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AirportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AirportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Airport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AirportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, airport.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.city != nil {
		fields = append(fields, airport.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, airport.FieldCountry)
	}
	if m.created_at != nil {
		fields = append(fields, airport.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldCode:
		return m.Code()
	case airport.FieldName:
		return m.Name()
	case airport.FieldCity:
		return m.City()
	case airport.FieldCountry:
		return m.Country()
	case airport.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldCode:
		return m.OldCode(ctx)
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldCity:
		return m.OldCity(ctx)
	case airport.FieldCountry:
		return m.OldCountry(ctx)
	case airport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case airport.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case airport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldCode:
		m.ResetCode()
		return nil
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldCity:
		m.ResetCity()
		return nil
	case airport.FieldCountry:
		m.ResetCountry()
		return nil
	case airport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.departures != nil {
		edges = append(edges, airport.EdgeDepartures)
	}
	if m.arrivals != nil {
		edges = append(edges, airport.EdgeArrivals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeDepartures:
		ids := make([]ent.Value, 0, len(m.departures))
		for id := range m.departures {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeArrivals:
		ids := make([]ent.Value, 0, len(m.arrivals))
		for id := range m.arrivals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddepartures != nil {
		edges = append(edges, airport.EdgeDepartures)
	}
	if m.removedarrivals != nil {
		edges = append(edges, airport.EdgeArrivals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeDepartures:
		ids := make([]ent.Value, 0, len(m.removeddepartures))
		for id := range m.removeddepartures {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeArrivals:
		ids := make([]ent.Value, 0, len(m.removedarrivals))
		for id := range m.removedarrivals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddepartures {
		edges = append(edges, airport.EdgeDepartures)
	}
	if m.clearedarrivals {
		edges = append(edges, airport.EdgeArrivals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeDepartures:
		return m.cleareddepartures
	case airport.EdgeArrivals:
		return m.clearedarrivals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeDepartures:
		m.ResetDepartures()
		return nil
	case airport.EdgeArrivals:
		m.ResetArrivals()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	booking_code              *string
	total_amount              *float64
	addtotal_amount           *float64
	status                    *string
	expires_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	user                      *uuid.UUID
	cleareduser               bool
	flight                    *uuid.UUID
	clearedflight             bool
	booking_passengers        map[uuid.UUID]struct{}
	removedbooking_passengers map[uuid.UUID]struct{}
	clearedbooking_passengers bool
	payments                  map[uuid.UUID]struct{}
	removedpayments           map[uuid.UUID]struct{}
	clearedpayments           bool
	done                      bool
	oldValue                  func(context.Context) (*Booking, error)
	predicates                []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id uuid.UUID) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Booking entities.
func (m *BookingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBookingCode sets the "booking_code" field.
func (m *BookingMutation) SetBookingCode(s string) {
	m.booking_code = &s
}

// BookingCode returns the value of the "booking_code" field in the mutation.
func (m *BookingMutation) BookingCode() (r string, exists bool) {
	v := m.booking_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingCode returns the old "booking_code" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldBookingCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookingCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookingCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingCode: %w", err)
	}
	return oldValue.BookingCode, nil
}

// ResetBookingCode resets all changes to the "booking_code" field.
func (m *BookingMutation) ResetBookingCode() {
	m.booking_code = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *BookingMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *BookingMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *BookingMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *BookingMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *BookingMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *BookingMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *BookingMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *BookingMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[booking.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *BookingMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[booking.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *BookingMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, booking.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *BookingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BookingMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BookingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BookingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BookingMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BookingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetFlightID sets the "flight" edge to the Flight entity by id.
func (m *BookingMutation) SetFlightID(id uuid.UUID) {
	m.flight = &id
}

// ClearFlight clears the "flight" edge to the Flight entity.
func (m *BookingMutation) ClearFlight() {
	m.clearedflight = true
}

// FlightCleared reports if the "flight" edge to the Flight entity was cleared.
func (m *BookingMutation) FlightCleared() bool {
	return m.clearedflight
}

// FlightID returns the "flight" edge ID in the mutation.
func (m *BookingMutation) FlightID() (id uuid.UUID, exists bool) {
	if m.flight != nil {
		return *m.flight, true
	}
	return
}

// FlightIDs returns the "flight" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) FlightIDs() (ids []uuid.UUID) {
	if id := m.flight; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlight resets all changes to the "flight" edge.
func (m *BookingMutation) ResetFlight() {
	m.flight = nil
	m.clearedflight = false
}

// AddBookingPassengerIDs adds the "booking_passengers" edge to the BookingPassenger entity by ids.
func (m *BookingMutation) AddBookingPassengerIDs(ids ...uuid.UUID) {
	if m.booking_passengers == nil {
		m.booking_passengers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.booking_passengers[ids[i]] = struct{}{}
	}
}

// ClearBookingPassengers clears the "booking_passengers" edge to the BookingPassenger entity.
func (m *BookingMutation) ClearBookingPassengers() {
	m.clearedbooking_passengers = true
}

// BookingPassengersCleared reports if the "booking_passengers" edge to the BookingPassenger entity was cleared.
func (m *BookingMutation) BookingPassengersCleared() bool {
	return m.clearedbooking_passengers
}

// RemoveBookingPassengerIDs removes the "booking_passengers" edge to the BookingPassenger entity by IDs.
func (m *BookingMutation) RemoveBookingPassengerIDs(ids ...uuid.UUID) {
	if m.removedbooking_passengers == nil {
		m.removedbooking_passengers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.booking_passengers, ids[i])
		m.removedbooking_passengers[ids[i]] = struct{}{}
	}
}

// RemovedBookingPassengers returns the removed IDs of the "booking_passengers" edge to the BookingPassenger entity.
func (m *BookingMutation) RemovedBookingPassengersIDs() (ids []uuid.UUID) {
	for id := range m.removedbooking_passengers {
		ids = append(ids, id)
	}
	return
}

// BookingPassengersIDs returns the "booking_passengers" edge IDs in the mutation.
func (m *BookingMutation) BookingPassengersIDs() (ids []uuid.UUID) {
	for id := range m.booking_passengers {
		ids = append(ids, id)
	}
	return
}

// ResetBookingPassengers resets all changes to the "booking_passengers" edge.
func (m *BookingMutation) ResetBookingPassengers() {
	m.booking_passengers = nil
	m.clearedbooking_passengers = false
	m.removedbooking_passengers = nil
}

// AddPaymentIDs adds the "payments" edge to the Payment entity by ids.
func (m *BookingMutation) AddPaymentIDs(ids ...uuid.UUID) {
	if m.payments == nil {
		m.payments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Payment entity.
func (m *BookingMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Payment entity was cleared.
func (m *BookingMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Payment entity by IDs.
func (m *BookingMutation) RemovePaymentIDs(ids ...uuid.UUID) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Payment entity.
func (m *BookingMutation) RemovedPaymentsIDs() (ids []uuid.UUID) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *BookingMutation) PaymentsIDs() (ids []uuid.UUID) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *BookingMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.booking_code != nil {
		fields = append(fields, booking.FieldBookingCode)
	}
	if m.total_amount != nil {
		fields = append(fields, booking.FieldTotalAmount)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, booking.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, booking.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldBookingCode:
		return m.BookingCode()
	case booking.FieldTotalAmount:
		return m.TotalAmount()
	case booking.FieldStatus:
		return m.Status()
	case booking.FieldExpiresAt:
		return m.ExpiresAt()
	case booking.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldBookingCode:
		return m.OldBookingCode(ctx)
	case booking.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	case booking.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case booking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldBookingCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingCode(v)
		return nil
	case booking.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case booking.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case booking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_amount != nil {
		fields = append(fields, booking.FieldTotalAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldTotalAmount:
		return m.AddedTotalAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case booking.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(booking.FieldExpiresAt) {
		fields = append(fields, booking.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	switch name {
	case booking.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldBookingCode:
		m.ResetBookingCode()
		return nil
	case booking.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	case booking.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case booking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, booking.EdgeUser)
	}
	if m.flight != nil {
		edges = append(edges, booking.EdgeFlight)
	}
	if m.booking_passengers != nil {
		edges = append(edges, booking.EdgeBookingPassengers)
	}
	if m.payments != nil {
		edges = append(edges, booking.EdgePayments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeFlight:
		if id := m.flight; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeBookingPassengers:
		ids := make([]ent.Value, 0, len(m.booking_passengers))
		for id := range m.booking_passengers {
			ids = append(ids, id)
		}
		return ids
	case booking.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbooking_passengers != nil {
		edges = append(edges, booking.EdgeBookingPassengers)
	}
	if m.removedpayments != nil {
		edges = append(edges, booking.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeBookingPassengers:
		ids := make([]ent.Value, 0, len(m.removedbooking_passengers))
		for id := range m.removedbooking_passengers {
			ids = append(ids, id)
		}
		return ids
	case booking.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, booking.EdgeUser)
	}
	if m.clearedflight {
		edges = append(edges, booking.EdgeFlight)
	}
	if m.clearedbooking_passengers {
		edges = append(edges, booking.EdgeBookingPassengers)
	}
	if m.clearedpayments {
		edges = append(edges, booking.EdgePayments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeUser:
		return m.cleareduser
	case booking.EdgeFlight:
		return m.clearedflight
	case booking.EdgeBookingPassengers:
		return m.clearedbooking_passengers
	case booking.EdgePayments:
		return m.clearedpayments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeUser:
		m.ClearUser()
		return nil
	case booking.EdgeFlight:
		m.ClearFlight()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeUser:
		m.ResetUser()
		return nil
	case booking.EdgeFlight:
		m.ResetFlight()
		return nil
	case booking.EdgeBookingPassengers:
		m.ResetBookingPassengers()
		return nil
	case booking.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// BookingPassengerMutation represents an operation that mutates the BookingPassenger nodes in the graph.
type BookingPassengerMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	clearedFields      map[string]struct{}
	booking            *uuid.UUID
	clearedbooking     bool
	passenger          *uuid.UUID
	clearedpassenger   bool
	flight_seat        *uuid.UUID
	clearedflight_seat bool
	done               bool
	oldValue           func(context.Context) (*BookingPassenger, error)
	predicates         []predicate.BookingPassenger
}

var _ ent.Mutation = (*BookingPassengerMutation)(nil)

// bookingpassengerOption allows management of the mutation configuration using functional options.
type bookingpassengerOption func(*BookingPassengerMutation)

// newBookingPassengerMutation creates new mutation for the BookingPassenger entity.
func newBookingPassengerMutation(c config, op Op, opts ...bookingpassengerOption) *BookingPassengerMutation {
	m := &BookingPassengerMutation{
		config:        c,
		op:            op,
		typ:           TypeBookingPassenger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingPassengerID sets the ID field of the mutation.
func withBookingPassengerID(id uuid.UUID) bookingpassengerOption {
	return func(m *BookingPassengerMutation) {
		var (
			err   error
			once  sync.Once
			value *BookingPassenger
		)
		m.oldValue = func(ctx context.Context) (*BookingPassenger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookingPassenger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookingPassenger sets the old BookingPassenger of the mutation.
func withBookingPassenger(node *BookingPassenger) bookingpassengerOption {
	return func(m *BookingPassengerMutation) {
		m.oldValue = func(context.Context) (*BookingPassenger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingPassengerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingPassengerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookingPassenger entities.
func (m *BookingPassengerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingPassengerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingPassengerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookingPassenger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBookingID sets the "booking" edge to the Booking entity by id.
func (m *BookingPassengerMutation) SetBookingID(id uuid.UUID) {
	m.booking = &id
}

// ClearBooking clears the "booking" edge to the Booking entity.
func (m *BookingPassengerMutation) ClearBooking() {
	m.clearedbooking = true
}

// BookingCleared reports if the "booking" edge to the Booking entity was cleared.
func (m *BookingPassengerMutation) BookingCleared() bool {
	return m.clearedbooking
}

// BookingID returns the "booking" edge ID in the mutation.
func (m *BookingPassengerMutation) BookingID() (id uuid.UUID, exists bool) {
	if m.booking != nil {
		return *m.booking, true
	}
	return
}

// BookingIDs returns the "booking" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingID instead. It exists only for internal usage by the builders.
func (m *BookingPassengerMutation) BookingIDs() (ids []uuid.UUID) {
	if id := m.booking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBooking resets all changes to the "booking" edge.
func (m *BookingPassengerMutation) ResetBooking() {
	m.booking = nil
	m.clearedbooking = false
}

// SetPassengerID sets the "passenger" edge to the Passenger entity by id.
func (m *BookingPassengerMutation) SetPassengerID(id uuid.UUID) {
	m.passenger = &id
}

// ClearPassenger clears the "passenger" edge to the Passenger entity.
func (m *BookingPassengerMutation) ClearPassenger() {
	m.clearedpassenger = true
}

// PassengerCleared reports if the "passenger" edge to the Passenger entity was cleared.
func (m *BookingPassengerMutation) PassengerCleared() bool {
	return m.clearedpassenger
}

// PassengerID returns the "passenger" edge ID in the mutation.
func (m *BookingPassengerMutation) PassengerID() (id uuid.UUID, exists bool) {
	if m.passenger != nil {
		return *m.passenger, true
	}
	return
}

// PassengerIDs returns the "passenger" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PassengerID instead. It exists only for internal usage by the builders.
func (m *BookingPassengerMutation) PassengerIDs() (ids []uuid.UUID) {
	if id := m.passenger; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassenger resets all changes to the "passenger" edge.
func (m *BookingPassengerMutation) ResetPassenger() {
	m.passenger = nil
	m.clearedpassenger = false
}

// SetFlightSeatID sets the "flight_seat" edge to the FlightSeat entity by id.
func (m *BookingPassengerMutation) SetFlightSeatID(id uuid.UUID) {
	m.flight_seat = &id
}

// ClearFlightSeat clears the "flight_seat" edge to the FlightSeat entity.
func (m *BookingPassengerMutation) ClearFlightSeat() {
	m.clearedflight_seat = true
}

// FlightSeatCleared reports if the "flight_seat" edge to the FlightSeat entity was cleared.
func (m *BookingPassengerMutation) FlightSeatCleared() bool {
	return m.clearedflight_seat
}

// FlightSeatID returns the "flight_seat" edge ID in the mutation.
func (m *BookingPassengerMutation) FlightSeatID() (id uuid.UUID, exists bool) {
	if m.flight_seat != nil {
		return *m.flight_seat, true
	}
	return
}

// FlightSeatIDs returns the "flight_seat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightSeatID instead. It exists only for internal usage by the builders.
func (m *BookingPassengerMutation) FlightSeatIDs() (ids []uuid.UUID) {
	if id := m.flight_seat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightSeat resets all changes to the "flight_seat" edge.
func (m *BookingPassengerMutation) ResetFlightSeat() {
	m.flight_seat = nil
	m.clearedflight_seat = false
}

// Where appends a list predicates to the BookingPassengerMutation builder.
func (m *BookingPassengerMutation) Where(ps ...predicate.BookingPassenger) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingPassengerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingPassengerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookingPassenger, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingPassengerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingPassengerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookingPassenger).
func (m *BookingPassengerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingPassengerMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingPassengerMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingPassengerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown BookingPassenger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingPassengerMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookingPassenger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingPassengerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingPassengerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingPassengerMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown BookingPassenger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingPassengerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingPassengerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingPassengerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BookingPassenger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingPassengerMutation) ResetField(name string) error {
	return fmt.Errorf("unknown BookingPassenger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingPassengerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.booking != nil {
		edges = append(edges, bookingpassenger.EdgeBooking)
	}
	if m.passenger != nil {
		edges = append(edges, bookingpassenger.EdgePassenger)
	}
	if m.flight_seat != nil {
		edges = append(edges, bookingpassenger.EdgeFlightSeat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingPassengerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookingpassenger.EdgeBooking:
		if id := m.booking; id != nil {
			return []ent.Value{*id}
		}
	case bookingpassenger.EdgePassenger:
		if id := m.passenger; id != nil {
			return []ent.Value{*id}
		}
	case bookingpassenger.EdgeFlightSeat:
		if id := m.flight_seat; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingPassengerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingPassengerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingPassengerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbooking {
		edges = append(edges, bookingpassenger.EdgeBooking)
	}
	if m.clearedpassenger {
		edges = append(edges, bookingpassenger.EdgePassenger)
	}
	if m.clearedflight_seat {
		edges = append(edges, bookingpassenger.EdgeFlightSeat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingPassengerMutation) EdgeCleared(name string) bool {
	switch name {
	case bookingpassenger.EdgeBooking:
		return m.clearedbooking
	case bookingpassenger.EdgePassenger:
		return m.clearedpassenger
	case bookingpassenger.EdgeFlightSeat:
		return m.clearedflight_seat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingPassengerMutation) ClearEdge(name string) error {
	switch name {
	case bookingpassenger.EdgeBooking:
		m.ClearBooking()
		return nil
	case bookingpassenger.EdgePassenger:
		m.ClearPassenger()
		return nil
	case bookingpassenger.EdgeFlightSeat:
		m.ClearFlightSeat()
		return nil
	}
	return fmt.Errorf("unknown BookingPassenger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingPassengerMutation) ResetEdge(name string) error {
	switch name {
	case bookingpassenger.EdgeBooking:
		m.ResetBooking()
		return nil
	case bookingpassenger.EdgePassenger:
		m.ResetPassenger()
		return nil
	case bookingpassenger.EdgeFlightSeat:
		m.ResetFlightSeat()
		return nil
	}
	return fmt.Errorf("unknown BookingPassenger edge %s", name)
}

// FlightMutation represents an operation that mutates the Flight nodes in the graph.
type FlightMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	flight_number            *string
	departure_time           *time.Time
	arrival_time             *time.Time
	base_price               *float64
	addbase_price            *float64
	status                   *string
	created_at               *time.Time
	clearedFields            map[string]struct{}
	aircraft                 *uuid.UUID
	clearedaircraft          bool
	departure_airport        *uuid.UUID
	cleareddeparture_airport bool
	arrival_airport          *uuid.UUID
	clearedarrival_airport   bool
	flight_seats             map[uuid.UUID]struct{}
	removedflight_seats      map[uuid.UUID]struct{}
	clearedflight_seats      bool
	bookings                 map[uuid.UUID]struct{}
	removedbookings          map[uuid.UUID]struct{}
	clearedbookings          bool
	done                     bool
	oldValue                 func(context.Context) (*Flight, error)
	predicates               []predicate.Flight
}

var _ ent.Mutation = (*FlightMutation)(nil)

// flightOption allows management of the mutation configuration using functional options.
type flightOption func(*FlightMutation)

// newFlightMutation creates new mutation for the Flight entity.
func newFlightMutation(c config, op Op, opts ...flightOption) *FlightMutation {
	m := &FlightMutation{
		config:        c,
		op:            op,
		typ:           TypeFlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightID sets the ID field of the mutation.
func withFlightID(id uuid.UUID) flightOption {
	return func(m *FlightMutation) {
		var (
			err   error
			once  sync.Once
			value *Flight
		)
		m.oldValue = func(ctx context.Context) (*Flight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Flight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlight sets the old Flight of the mutation.
func withFlight(node *Flight) flightOption {
	return func(m *FlightMutation) {
		m.oldValue = func(context.Context) (*Flight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Flight entities.
func (m *FlightMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Flight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlightNumber sets the "flight_number" field.
func (m *FlightMutation) SetFlightNumber(s string) {
	m.flight_number = &s
}

// FlightNumber returns the value of the "flight_number" field in the mutation.
func (m *FlightMutation) FlightNumber() (r string, exists bool) {
	v := m.flight_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightNumber returns the old "flight_number" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldFlightNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightNumber: %w", err)
	}
	return oldValue.FlightNumber, nil
}

// ResetFlightNumber resets all changes to the "flight_number" field.
func (m *FlightMutation) ResetFlightNumber() {
	m.flight_number = nil
}

// SetDepartureTime sets the "departure_time" field.
func (m *FlightMutation) SetDepartureTime(t time.Time) {
	m.departure_time = &t
}

// DepartureTime returns the value of the "departure_time" field in the mutation.
func (m *FlightMutation) DepartureTime() (r time.Time, exists bool) {
	v := m.departure_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureTime returns the old "departure_time" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldDepartureTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureTime: %w", err)
	}
	return oldValue.DepartureTime, nil
}

// ResetDepartureTime resets all changes to the "departure_time" field.
func (m *FlightMutation) ResetDepartureTime() {
	m.departure_time = nil
}

// SetArrivalTime sets the "arrival_time" field.
func (m *FlightMutation) SetArrivalTime(t time.Time) {
	m.arrival_time = &t
}

// ArrivalTime returns the value of the "arrival_time" field in the mutation.
func (m *FlightMutation) ArrivalTime() (r time.Time, exists bool) {
	v := m.arrival_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivalTime returns the old "arrival_time" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldArrivalTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivalTime: %w", err)
	}
	return oldValue.ArrivalTime, nil
}

// ResetArrivalTime resets all changes to the "arrival_time" field.
func (m *FlightMutation) ResetArrivalTime() {
	m.arrival_time = nil
}

// SetBasePrice sets the "base_price" field.
func (m *FlightMutation) SetBasePrice(f float64) {
	m.base_price = &f
	m.addbase_price = nil
}

// BasePrice returns the value of the "base_price" field in the mutation.
func (m *FlightMutation) BasePrice() (r float64, exists bool) {
	v := m.base_price
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePrice returns the old "base_price" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldBasePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePrice: %w", err)
	}
	return oldValue.BasePrice, nil
}

// AddBasePrice adds f to the "base_price" field.
func (m *FlightMutation) AddBasePrice(f float64) {
	if m.addbase_price != nil {
		*m.addbase_price += f
	} else {
		m.addbase_price = &f
	}
}

// AddedBasePrice returns the value that was added to the "base_price" field in this mutation.
func (m *FlightMutation) AddedBasePrice() (r float64, exists bool) {
	v := m.addbase_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetBasePrice resets all changes to the "base_price" field.
func (m *FlightMutation) ResetBasePrice() {
	m.base_price = nil
	m.addbase_price = nil
}

// SetStatus sets the "status" field.
func (m *FlightMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FlightMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FlightMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAircraftID sets the "aircraft" edge to the Aircraft entity by id.
func (m *FlightMutation) SetAircraftID(id uuid.UUID) {
	m.aircraft = &id
}

// ClearAircraft clears the "aircraft" edge to the Aircraft entity.
func (m *FlightMutation) ClearAircraft() {
	m.clearedaircraft = true
}

// AircraftCleared reports if the "aircraft" edge to the Aircraft entity was cleared.
func (m *FlightMutation) AircraftCleared() bool {
	return m.clearedaircraft
}

// AircraftID returns the "aircraft" edge ID in the mutation.
func (m *FlightMutation) AircraftID() (id uuid.UUID, exists bool) {
	if m.aircraft != nil {
		return *m.aircraft, true
	}
	return
}

// AircraftIDs returns the "aircraft" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AircraftID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) AircraftIDs() (ids []uuid.UUID) {
	if id := m.aircraft; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAircraft resets all changes to the "aircraft" edge.
func (m *FlightMutation) ResetAircraft() {
	m.aircraft = nil
	m.clearedaircraft = false
}

// SetDepartureAirportID sets the "departure_airport" edge to the Airport entity by id.
func (m *FlightMutation) SetDepartureAirportID(id uuid.UUID) {
	m.departure_airport = &id
}

// ClearDepartureAirport clears the "departure_airport" edge to the Airport entity.
func (m *FlightMutation) ClearDepartureAirport() {
	m.cleareddeparture_airport = true
}

// DepartureAirportCleared reports if the "departure_airport" edge to the Airport entity was cleared.
func (m *FlightMutation) DepartureAirportCleared() bool {
	return m.cleareddeparture_airport
}

// DepartureAirportID returns the "departure_airport" edge ID in the mutation.
func (m *FlightMutation) DepartureAirportID() (id uuid.UUID, exists bool) {
	if m.departure_airport != nil {
		return *m.departure_airport, true
	}
	return
}

// DepartureAirportIDs returns the "departure_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartureAirportID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) DepartureAirportIDs() (ids []uuid.UUID) {
	if id := m.departure_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartureAirport resets all changes to the "departure_airport" edge.
func (m *FlightMutation) ResetDepartureAirport() {
	m.departure_airport = nil
	m.cleareddeparture_airport = false
}

// SetArrivalAirportID sets the "arrival_airport" edge to the Airport entity by id.
func (m *FlightMutation) SetArrivalAirportID(id uuid.UUID) {
	m.arrival_airport = &id
}

// ClearArrivalAirport clears the "arrival_airport" edge to the Airport entity.
func (m *FlightMutation) ClearArrivalAirport() {
	m.clearedarrival_airport = true
}

// ArrivalAirportCleared reports if the "arrival_airport" edge to the Airport entity was cleared.
func (m *FlightMutation) ArrivalAirportCleared() bool {
	return m.clearedarrival_airport
}

// ArrivalAirportID returns the "arrival_airport" edge ID in the mutation.
func (m *FlightMutation) ArrivalAirportID() (id uuid.UUID, exists bool) {
	if m.arrival_airport != nil {
		return *m.arrival_airport, true
	}
	return
}

// ArrivalAirportIDs returns the "arrival_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArrivalAirportID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) ArrivalAirportIDs() (ids []uuid.UUID) {
	if id := m.arrival_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArrivalAirport resets all changes to the "arrival_airport" edge.
func (m *FlightMutation) ResetArrivalAirport() {
	m.arrival_airport = nil
	m.clearedarrival_airport = false
}

// AddFlightSeatIDs adds the "flight_seats" edge to the FlightSeat entity by ids.
func (m *FlightMutation) AddFlightSeatIDs(ids ...uuid.UUID) {
	if m.flight_seats == nil {
		m.flight_seats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_seats[ids[i]] = struct{}{}
	}
}

// ClearFlightSeats clears the "flight_seats" edge to the FlightSeat entity.
func (m *FlightMutation) ClearFlightSeats() {
	m.clearedflight_seats = true
}

// FlightSeatsCleared reports if the "flight_seats" edge to the FlightSeat entity was cleared.
func (m *FlightMutation) FlightSeatsCleared() bool {
	return m.clearedflight_seats
}

// RemoveFlightSeatIDs removes the "flight_seats" edge to the FlightSeat entity by IDs.
func (m *FlightMutation) RemoveFlightSeatIDs(ids ...uuid.UUID) {
	if m.removedflight_seats == nil {
		m.removedflight_seats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_seats, ids[i])
		m.removedflight_seats[ids[i]] = struct{}{}
	}
}

// RemovedFlightSeats returns the removed IDs of the "flight_seats" edge to the FlightSeat entity.
func (m *FlightMutation) RemovedFlightSeatsIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_seats {
		ids = append(ids, id)
	}
	return
}

// FlightSeatsIDs returns the "flight_seats" edge IDs in the mutation.
func (m *FlightMutation) FlightSeatsIDs() (ids []uuid.UUID) {
	for id := range m.flight_seats {
		ids = append(ids, id)
	}
	return
}

// ResetFlightSeats resets all changes to the "flight_seats" edge.
func (m *FlightMutation) ResetFlightSeats() {
	m.flight_seats = nil
	m.clearedflight_seats = false
	m.removedflight_seats = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *FlightMutation) AddBookingIDs(ids ...uuid.UUID) {
	if m.bookings == nil {
		m.bookings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *FlightMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *FlightMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *FlightMutation) RemoveBookingIDs(ids ...uuid.UUID) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *FlightMutation) RemovedBookingsIDs() (ids []uuid.UUID) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *FlightMutation) BookingsIDs() (ids []uuid.UUID) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *FlightMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// Where appends a list predicates to the FlightMutation builder.
func (m *FlightMutation) Where(ps ...predicate.Flight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FlightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FlightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Flight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FlightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FlightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Flight).
func (m *FlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.flight_number != nil {
		fields = append(fields, flight.FieldFlightNumber)
	}
	if m.departure_time != nil {
		fields = append(fields, flight.FieldDepartureTime)
	}
	if m.arrival_time != nil {
		fields = append(fields, flight.FieldArrivalTime)
	}
	if m.base_price != nil {
		fields = append(fields, flight.FieldBasePrice)
	}
	if m.status != nil {
		fields = append(fields, flight.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, flight.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldFlightNumber:
		return m.FlightNumber()
	case flight.FieldDepartureTime:
		return m.DepartureTime()
	case flight.FieldArrivalTime:
		return m.ArrivalTime()
	case flight.FieldBasePrice:
		return m.BasePrice()
	case flight.FieldStatus:
		return m.Status()
	case flight.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flight.FieldFlightNumber:
		return m.OldFlightNumber(ctx)
	case flight.FieldDepartureTime:
		return m.OldDepartureTime(ctx)
	case flight.FieldArrivalTime:
		return m.OldArrivalTime(ctx)
	case flight.FieldBasePrice:
		return m.OldBasePrice(ctx)
	case flight.FieldStatus:
		return m.OldStatus(ctx)
	case flight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Flight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flight.FieldFlightNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightNumber(v)
		return nil
	case flight.FieldDepartureTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureTime(v)
		return nil
	case flight.FieldArrivalTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivalTime(v)
		return nil
	case flight.FieldBasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePrice(v)
		return nil
	case flight.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightMutation) AddedFields() []string {
	var fields []string
	if m.addbase_price != nil {
		fields = append(fields, flight.FieldBasePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldBasePrice:
		return m.AddedBasePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flight.FieldBasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBasePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Flight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Flight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightMutation) ResetField(name string) error {
	switch name {
	case flight.FieldFlightNumber:
		m.ResetFlightNumber()
		return nil
	case flight.FieldDepartureTime:
		m.ResetDepartureTime()
		return nil
	case flight.FieldArrivalTime:
		m.ResetArrivalTime()
		return nil
	case flight.FieldBasePrice:
		m.ResetBasePrice()
		return nil
	case flight.FieldStatus:
		m.ResetStatus()
		return nil
	case flight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.aircraft != nil {
		edges = append(edges, flight.EdgeAircraft)
	}
	if m.departure_airport != nil {
		edges = append(edges, flight.EdgeDepartureAirport)
	}
	if m.arrival_airport != nil {
		edges = append(edges, flight.EdgeArrivalAirport)
	}
	if m.flight_seats != nil {
		edges = append(edges, flight.EdgeFlightSeats)
	}
	if m.bookings != nil {
		edges = append(edges, flight.EdgeBookings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeAircraft:
		if id := m.aircraft; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeDepartureAirport:
		if id := m.departure_airport; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeArrivalAirport:
		if id := m.arrival_airport; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeFlightSeats:
		ids := make([]ent.Value, 0, len(m.flight_seats))
		for id := range m.flight_seats {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedflight_seats != nil {
		edges = append(edges, flight.EdgeFlightSeats)
	}
	if m.removedbookings != nil {
		edges = append(edges, flight.EdgeBookings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeFlightSeats:
		ids := make([]ent.Value, 0, len(m.removedflight_seats))
		for id := range m.removedflight_seats {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedaircraft {
		edges = append(edges, flight.EdgeAircraft)
	}
	if m.cleareddeparture_airport {
		edges = append(edges, flight.EdgeDepartureAirport)
	}
	if m.clearedarrival_airport {
		edges = append(edges, flight.EdgeArrivalAirport)
	}
	if m.clearedflight_seats {
		edges = append(edges, flight.EdgeFlightSeats)
	}
	if m.clearedbookings {
		edges = append(edges, flight.EdgeBookings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightMutation) EdgeCleared(name string) bool {
	switch name {
	case flight.EdgeAircraft:
		return m.clearedaircraft
	case flight.EdgeDepartureAirport:
		return m.cleareddeparture_airport
	case flight.EdgeArrivalAirport:
		return m.clearedarrival_airport
	case flight.EdgeFlightSeats:
		return m.clearedflight_seats
	case flight.EdgeBookings:
		return m.clearedbookings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightMutation) ClearEdge(name string) error {
	switch name {
	case flight.EdgeAircraft:
		m.ClearAircraft()
		return nil
	case flight.EdgeDepartureAirport:
		m.ClearDepartureAirport()
		return nil
	case flight.EdgeArrivalAirport:
		m.ClearArrivalAirport()
		return nil
	}
	return fmt.Errorf("unknown Flight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightMutation) ResetEdge(name string) error {
	switch name {
	case flight.EdgeAircraft:
		m.ResetAircraft()
		return nil
	case flight.EdgeDepartureAirport:
		m.ResetDepartureAirport()
		return nil
	case flight.EdgeArrivalAirport:
		m.ResetArrivalAirport()
		return nil
	case flight.EdgeFlightSeats:
		m.ResetFlightSeats()
		return nil
	case flight.EdgeBookings:
		m.ResetBookings()
		return nil
	}
	return fmt.Errorf("unknown Flight edge %s", name)
}

// FlightSeatMutation represents an operation that mutates the FlightSeat nodes in the graph.
type FlightSeatMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	status          *string
	price           *float64
	addprice        *float64
	clearedFields   map[string]struct{}
	flight          *uuid.UUID
	clearedflight   bool
	seat            *uuid.UUID
	clearedseat     bool
	assigned        map[uuid.UUID]struct{}
	removedassigned map[uuid.UUID]struct{}
	clearedassigned bool
	done            bool
	oldValue        func(context.Context) (*FlightSeat, error)
	predicates      []predicate.FlightSeat
}

var _ ent.Mutation = (*FlightSeatMutation)(nil)

// flightseatOption allows management of the mutation configuration using functional options.
type flightseatOption func(*FlightSeatMutation)

// newFlightSeatMutation creates new mutation for the FlightSeat entity.
func newFlightSeatMutation(c config, op Op, opts ...flightseatOption) *FlightSeatMutation {
	m := &FlightSeatMutation{
		config:        c,
		op:            op,
		typ:           TypeFlightSeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightSeatID sets the ID field of the mutation.
func withFlightSeatID(id uuid.UUID) flightseatOption {
	return func(m *FlightSeatMutation) {
		var (
			err   error
			once  sync.Once
			value *FlightSeat
		)
		m.oldValue = func(ctx context.Context) (*FlightSeat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlightSeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlightSeat sets the old FlightSeat of the mutation.
func withFlightSeat(node *FlightSeat) flightseatOption {
	return func(m *FlightSeatMutation) {
		m.oldValue = func(context.Context) (*FlightSeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightSeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightSeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlightSeat entities.
func (m *FlightSeatMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightSeatMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightSeatMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlightSeat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *FlightSeatMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FlightSeatMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FlightSeat entity.
// If the FlightSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightSeatMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FlightSeatMutation) ResetStatus() {
	m.status = nil
}

// SetPrice sets the "price" field.
func (m *FlightSeatMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *FlightSeatMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the FlightSeat entity.
// If the FlightSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightSeatMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *FlightSeatMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *FlightSeatMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *FlightSeatMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetFlightID sets the "flight" edge to the Flight entity by id.
func (m *FlightSeatMutation) SetFlightID(id uuid.UUID) {
	m.flight = &id
}

// ClearFlight clears the "flight" edge to the Flight entity.
func (m *FlightSeatMutation) ClearFlight() {
	m.clearedflight = true
}

// FlightCleared reports if the "flight" edge to the Flight entity was cleared.
func (m *FlightSeatMutation) FlightCleared() bool {
	return m.clearedflight
}

// FlightID returns the "flight" edge ID in the mutation.
func (m *FlightSeatMutation) FlightID() (id uuid.UUID, exists bool) {
	if m.flight != nil {
		return *m.flight, true
	}
	return
}

// FlightIDs returns the "flight" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightID instead. It exists only for internal usage by the builders.
func (m *FlightSeatMutation) FlightIDs() (ids []uuid.UUID) {
	if id := m.flight; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlight resets all changes to the "flight" edge.
func (m *FlightSeatMutation) ResetFlight() {
	m.flight = nil
	m.clearedflight = false
}

// SetSeatID sets the "seat" edge to the Seats entity by id.
func (m *FlightSeatMutation) SetSeatID(id uuid.UUID) {
	m.seat = &id
}

// ClearSeat clears the "seat" edge to the Seats entity.
func (m *FlightSeatMutation) ClearSeat() {
	m.clearedseat = true
}

// SeatCleared reports if the "seat" edge to the Seats entity was cleared.
func (m *FlightSeatMutation) SeatCleared() bool {
	return m.clearedseat
}

// SeatID returns the "seat" edge ID in the mutation.
func (m *FlightSeatMutation) SeatID() (id uuid.UUID, exists bool) {
	if m.seat != nil {
		return *m.seat, true
	}
	return
}

// SeatIDs returns the "seat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeatID instead. It exists only for internal usage by the builders.
func (m *FlightSeatMutation) SeatIDs() (ids []uuid.UUID) {
	if id := m.seat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeat resets all changes to the "seat" edge.
func (m *FlightSeatMutation) ResetSeat() {
	m.seat = nil
	m.clearedseat = false
}

// AddAssignedIDs adds the "assigned" edge to the BookingPassenger entity by ids.
func (m *FlightSeatMutation) AddAssignedIDs(ids ...uuid.UUID) {
	if m.assigned == nil {
		m.assigned = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assigned[ids[i]] = struct{}{}
	}
}

// ClearAssigned clears the "assigned" edge to the BookingPassenger entity.
func (m *FlightSeatMutation) ClearAssigned() {
	m.clearedassigned = true
}

// AssignedCleared reports if the "assigned" edge to the BookingPassenger entity was cleared.
func (m *FlightSeatMutation) AssignedCleared() bool {
	return m.clearedassigned
}

// RemoveAssignedIDs removes the "assigned" edge to the BookingPassenger entity by IDs.
func (m *FlightSeatMutation) RemoveAssignedIDs(ids ...uuid.UUID) {
	if m.removedassigned == nil {
		m.removedassigned = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assigned, ids[i])
		m.removedassigned[ids[i]] = struct{}{}
	}
}

// RemovedAssigned returns the removed IDs of the "assigned" edge to the BookingPassenger entity.
func (m *FlightSeatMutation) RemovedAssignedIDs() (ids []uuid.UUID) {
	for id := range m.removedassigned {
		ids = append(ids, id)
	}
	return
}

// AssignedIDs returns the "assigned" edge IDs in the mutation.
func (m *FlightSeatMutation) AssignedIDs() (ids []uuid.UUID) {
	for id := range m.assigned {
		ids = append(ids, id)
	}
	return
}

// ResetAssigned resets all changes to the "assigned" edge.
func (m *FlightSeatMutation) ResetAssigned() {
	m.assigned = nil
	m.clearedassigned = false
	m.removedassigned = nil
}

// Where appends a list predicates to the FlightSeatMutation builder.
func (m *FlightSeatMutation) Where(ps ...predicate.FlightSeat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FlightSeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FlightSeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FlightSeat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FlightSeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FlightSeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FlightSeat).
func (m *FlightSeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightSeatMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, flightseat.FieldStatus)
	}
	if m.price != nil {
		fields = append(fields, flightseat.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightSeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flightseat.FieldStatus:
		return m.Status()
	case flightseat.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightSeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flightseat.FieldStatus:
		return m.OldStatus(ctx)
	case flightseat.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown FlightSeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightSeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flightseat.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flightseat.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown FlightSeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightSeatMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, flightseat.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightSeatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flightseat.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightSeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flightseat.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown FlightSeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightSeatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightSeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightSeatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlightSeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightSeatMutation) ResetField(name string) error {
	switch name {
	case flightseat.FieldStatus:
		m.ResetStatus()
		return nil
	case flightseat.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown FlightSeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightSeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.flight != nil {
		edges = append(edges, flightseat.EdgeFlight)
	}
	if m.seat != nil {
		edges = append(edges, flightseat.EdgeSeat)
	}
	if m.assigned != nil {
		edges = append(edges, flightseat.EdgeAssigned)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightSeatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flightseat.EdgeFlight:
		if id := m.flight; id != nil {
			return []ent.Value{*id}
		}
	case flightseat.EdgeSeat:
		if id := m.seat; id != nil {
			return []ent.Value{*id}
		}
	case flightseat.EdgeAssigned:
		ids := make([]ent.Value, 0, len(m.assigned))
		for id := range m.assigned {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightSeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedassigned != nil {
		edges = append(edges, flightseat.EdgeAssigned)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightSeatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flightseat.EdgeAssigned:
		ids := make([]ent.Value, 0, len(m.removedassigned))
		for id := range m.removedassigned {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightSeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedflight {
		edges = append(edges, flightseat.EdgeFlight)
	}
	if m.clearedseat {
		edges = append(edges, flightseat.EdgeSeat)
	}
	if m.clearedassigned {
		edges = append(edges, flightseat.EdgeAssigned)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightSeatMutation) EdgeCleared(name string) bool {
	switch name {
	case flightseat.EdgeFlight:
		return m.clearedflight
	case flightseat.EdgeSeat:
		return m.clearedseat
	case flightseat.EdgeAssigned:
		return m.clearedassigned
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightSeatMutation) ClearEdge(name string) error {
	switch name {
	case flightseat.EdgeFlight:
		m.ClearFlight()
		return nil
	case flightseat.EdgeSeat:
		m.ClearSeat()
		return nil
	}
	return fmt.Errorf("unknown FlightSeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightSeatMutation) ResetEdge(name string) error {
	switch name {
	case flightseat.EdgeFlight:
		m.ResetFlight()
		return nil
	case flightseat.EdgeSeat:
		m.ResetSeat()
		return nil
	case flightseat.EdgeAssigned:
		m.ResetAssigned()
		return nil
	}
	return fmt.Errorf("unknown FlightSeat edge %s", name)
}

// PassengerMutation represents an operation that mutates the Passenger nodes in the graph.
type PassengerMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	first_name             *string
	last_name              *string
	date_of_birth          *time.Time
	passport_number        *string
	created_at             *time.Time
	clearedFields          map[string]struct{}
	booking_entries        map[uuid.UUID]struct{}
	removedbooking_entries map[uuid.UUID]struct{}
	clearedbooking_entries bool
	done                   bool
	oldValue               func(context.Context) (*Passenger, error)
	predicates             []predicate.Passenger
}

var _ ent.Mutation = (*PassengerMutation)(nil)

// passengerOption allows management of the mutation configuration using functional options.
type passengerOption func(*PassengerMutation)

// newPassengerMutation creates new mutation for the Passenger entity.
func newPassengerMutation(c config, op Op, opts ...passengerOption) *PassengerMutation {
	m := &PassengerMutation{
		config:        c,
		op:            op,
		typ:           TypePassenger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPassengerID sets the ID field of the mutation.
func withPassengerID(id uuid.UUID) passengerOption {
	return func(m *PassengerMutation) {
		var (
			err   error
			once  sync.Once
			value *Passenger
		)
		m.oldValue = func(ctx context.Context) (*Passenger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passenger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassenger sets the old Passenger of the mutation.
func withPassenger(node *Passenger) passengerOption {
	return func(m *PassengerMutation) {
		m.oldValue = func(context.Context) (*Passenger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PassengerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PassengerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Passenger entities.
func (m *PassengerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PassengerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PassengerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passenger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *PassengerMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *PassengerMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *PassengerMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *PassengerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *PassengerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *PassengerMutation) ResetLastName() {
	m.last_name = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *PassengerMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *PassengerMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *PassengerMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
}

// SetPassportNumber sets the "passport_number" field.
func (m *PassengerMutation) SetPassportNumber(s string) {
	m.passport_number = &s
}

// PassportNumber returns the value of the "passport_number" field in the mutation.
func (m *PassengerMutation) PassportNumber() (r string, exists bool) {
	v := m.passport_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPassportNumber returns the old "passport_number" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldPassportNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassportNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassportNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassportNumber: %w", err)
	}
	return oldValue.PassportNumber, nil
}

// ClearPassportNumber clears the value of the "passport_number" field.
func (m *PassengerMutation) ClearPassportNumber() {
	m.passport_number = nil
	m.clearedFields[passenger.FieldPassportNumber] = struct{}{}
}

// PassportNumberCleared returns if the "passport_number" field was cleared in this mutation.
func (m *PassengerMutation) PassportNumberCleared() bool {
	_, ok := m.clearedFields[passenger.FieldPassportNumber]
	return ok
}

// ResetPassportNumber resets all changes to the "passport_number" field.
func (m *PassengerMutation) ResetPassportNumber() {
	m.passport_number = nil
	delete(m.clearedFields, passenger.FieldPassportNumber)
}

// SetCreatedAt sets the "created_at" field.
func (m *PassengerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PassengerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PassengerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddBookingEntryIDs adds the "booking_entries" edge to the BookingPassenger entity by ids.
func (m *PassengerMutation) AddBookingEntryIDs(ids ...uuid.UUID) {
	if m.booking_entries == nil {
		m.booking_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.booking_entries[ids[i]] = struct{}{}
	}
}

// ClearBookingEntries clears the "booking_entries" edge to the BookingPassenger entity.
func (m *PassengerMutation) ClearBookingEntries() {
	m.clearedbooking_entries = true
}

// BookingEntriesCleared reports if the "booking_entries" edge to the BookingPassenger entity was cleared.
func (m *PassengerMutation) BookingEntriesCleared() bool {
	return m.clearedbooking_entries
}

// RemoveBookingEntryIDs removes the "booking_entries" edge to the BookingPassenger entity by IDs.
func (m *PassengerMutation) RemoveBookingEntryIDs(ids ...uuid.UUID) {
	if m.removedbooking_entries == nil {
		m.removedbooking_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.booking_entries, ids[i])
		m.removedbooking_entries[ids[i]] = struct{}{}
	}
}

// RemovedBookingEntries returns the removed IDs of the "booking_entries" edge to the BookingPassenger entity.
func (m *PassengerMutation) RemovedBookingEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedbooking_entries {
		ids = append(ids, id)
	}
	return
}

// BookingEntriesIDs returns the "booking_entries" edge IDs in the mutation.
func (m *PassengerMutation) BookingEntriesIDs() (ids []uuid.UUID) {
	for id := range m.booking_entries {
		ids = append(ids, id)
	}
	return
}

// ResetBookingEntries resets all changes to the "booking_entries" edge.
func (m *PassengerMutation) ResetBookingEntries() {
	m.booking_entries = nil
	m.clearedbooking_entries = false
	m.removedbooking_entries = nil
}

// Where appends a list predicates to the PassengerMutation builder.
func (m *PassengerMutation) Where(ps ...predicate.Passenger) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PassengerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PassengerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passenger, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PassengerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PassengerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passenger).
func (m *PassengerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PassengerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.first_name != nil {
		fields = append(fields, passenger.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, passenger.FieldLastName)
	}
	if m.date_of_birth != nil {
		fields = append(fields, passenger.FieldDateOfBirth)
	}
	if m.passport_number != nil {
		fields = append(fields, passenger.FieldPassportNumber)
	}
	if m.created_at != nil {
		fields = append(fields, passenger.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PassengerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passenger.FieldFirstName:
		return m.FirstName()
	case passenger.FieldLastName:
		return m.LastName()
	case passenger.FieldDateOfBirth:
		return m.DateOfBirth()
	case passenger.FieldPassportNumber:
		return m.PassportNumber()
	case passenger.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PassengerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passenger.FieldFirstName:
		return m.OldFirstName(ctx)
	case passenger.FieldLastName:
		return m.OldLastName(ctx)
	case passenger.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case passenger.FieldPassportNumber:
		return m.OldPassportNumber(ctx)
	case passenger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Passenger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassengerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passenger.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case passenger.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case passenger.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case passenger.FieldPassportNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassportNumber(v)
		return nil
	case passenger.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Passenger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PassengerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PassengerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassengerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Passenger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PassengerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passenger.FieldPassportNumber) {
		fields = append(fields, passenger.FieldPassportNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PassengerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PassengerMutation) ClearField(name string) error {
	switch name {
	case passenger.FieldPassportNumber:
		m.ClearPassportNumber()
		return nil
	}
	return fmt.Errorf("unknown Passenger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PassengerMutation) ResetField(name string) error {
	switch name {
	case passenger.FieldFirstName:
		m.ResetFirstName()
		return nil
	case passenger.FieldLastName:
		m.ResetLastName()
		return nil
	case passenger.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case passenger.FieldPassportNumber:
		m.ResetPassportNumber()
		return nil
	case passenger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Passenger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PassengerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booking_entries != nil {
		edges = append(edges, passenger.EdgeBookingEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PassengerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passenger.EdgeBookingEntries:
		ids := make([]ent.Value, 0, len(m.booking_entries))
		for id := range m.booking_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PassengerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooking_entries != nil {
		edges = append(edges, passenger.EdgeBookingEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PassengerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case passenger.EdgeBookingEntries:
		ids := make([]ent.Value, 0, len(m.removedbooking_entries))
		for id := range m.removedbooking_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PassengerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooking_entries {
		edges = append(edges, passenger.EdgeBookingEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PassengerMutation) EdgeCleared(name string) bool {
	switch name {
	case passenger.EdgeBookingEntries:
		return m.clearedbooking_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PassengerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Passenger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PassengerMutation) ResetEdge(name string) error {
	switch name {
	case passenger.EdgeBookingEntries:
		m.ResetBookingEntries()
		return nil
	}
	return fmt.Errorf("unknown Passenger edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	amount         *float64
	addamount      *float64
	provider       *string
	status         *string
	paid_at        *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	booking        *uuid.UUID
	clearedbooking bool
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id uuid.UUID) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetProvider sets the "provider" field.
func (m *PaymentMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *PaymentMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *PaymentMutation) ResetProvider() {
	m.provider = nil
}

// SetStatus sets the "status" field.
func (m *PaymentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentMutation) ResetStatus() {
	m.status = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PaymentMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PaymentMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *PaymentMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[payment.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *PaymentMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[payment.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PaymentMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, payment.FieldPaidAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetBookingID sets the "booking" edge to the Booking entity by id.
func (m *PaymentMutation) SetBookingID(id uuid.UUID) {
	m.booking = &id
}

// ClearBooking clears the "booking" edge to the Booking entity.
func (m *PaymentMutation) ClearBooking() {
	m.clearedbooking = true
}

// BookingCleared reports if the "booking" edge to the Booking entity was cleared.
func (m *PaymentMutation) BookingCleared() bool {
	return m.clearedbooking
}

// BookingID returns the "booking" edge ID in the mutation.
func (m *PaymentMutation) BookingID() (id uuid.UUID, exists bool) {
	if m.booking != nil {
		return *m.booking, true
	}
	return
}

// BookingIDs returns the "booking" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) BookingIDs() (ids []uuid.UUID) {
	if id := m.booking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBooking resets all changes to the "booking" edge.
func (m *PaymentMutation) ResetBooking() {
	m.booking = nil
	m.clearedbooking = false
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.provider != nil {
		fields = append(fields, payment.FieldProvider)
	}
	if m.status != nil {
		fields = append(fields, payment.FieldStatus)
	}
	if m.paid_at != nil {
		fields = append(fields, payment.FieldPaidAt)
	}
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldProvider:
		return m.Provider()
	case payment.FieldStatus:
		return m.Status()
	case payment.FieldPaidAt:
		return m.PaidAt()
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldProvider:
		return m.OldProvider(ctx)
	case payment.FieldStatus:
		return m.OldStatus(ctx)
	case payment.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case payment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payment.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldPaidAt) {
		fields = append(fields, payment.FieldPaidAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldProvider:
		m.ResetProvider()
		return nil
	case payment.FieldStatus:
		m.ResetStatus()
		return nil
	case payment.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booking != nil {
		edges = append(edges, payment.EdgeBooking)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeBooking:
		if id := m.booking; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooking {
		edges = append(edges, payment.EdgeBooking)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeBooking:
		return m.clearedbooking
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeBooking:
		m.ClearBooking()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeBooking:
		m.ResetBooking()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// SeatsMutation represents an operation that mutates the Seats nodes in the graph.
type SeatsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	seat_number             *string
	seat_class              *string
	clearedFields           map[string]struct{}
	aircraft                *uuid.UUID
	clearedaircraft         bool
	flight_instances        map[uuid.UUID]struct{}
	removedflight_instances map[uuid.UUID]struct{}
	clearedflight_instances bool
	done                    bool
	oldValue                func(context.Context) (*Seats, error)
	predicates              []predicate.Seats
}

var _ ent.Mutation = (*SeatsMutation)(nil)

// seatsOption allows management of the mutation configuration using functional options.
type seatsOption func(*SeatsMutation)

// newSeatsMutation creates new mutation for the Seats entity.
func newSeatsMutation(c config, op Op, opts ...seatsOption) *SeatsMutation {
	m := &SeatsMutation{
		config:        c,
		op:            op,
		typ:           TypeSeats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeatsID sets the ID field of the mutation.
func withSeatsID(id uuid.UUID) seatsOption {
	return func(m *SeatsMutation) {
		var (
			err   error
			once  sync.Once
			value *Seats
		)
		m.oldValue = func(ctx context.Context) (*Seats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Seats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeats sets the old Seats of the mutation.
func withSeats(node *Seats) seatsOption {
	return func(m *SeatsMutation) {
		m.oldValue = func(context.Context) (*Seats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Seats entities.
func (m *SeatsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeatsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeatsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Seats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeatNumber sets the "seat_number" field.
func (m *SeatsMutation) SetSeatNumber(s string) {
	m.seat_number = &s
}

// SeatNumber returns the value of the "seat_number" field in the mutation.
func (m *SeatsMutation) SeatNumber() (r string, exists bool) {
	v := m.seat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatNumber returns the old "seat_number" field's value of the Seats entity.
// If the Seats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatsMutation) OldSeatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatNumber: %w", err)
	}
	return oldValue.SeatNumber, nil
}

// ResetSeatNumber resets all changes to the "seat_number" field.
func (m *SeatsMutation) ResetSeatNumber() {
	m.seat_number = nil
}

// SetSeatClass sets the "seat_class" field.
func (m *SeatsMutation) SetSeatClass(s string) {
	m.seat_class = &s
}

// SeatClass returns the value of the "seat_class" field in the mutation.
func (m *SeatsMutation) SeatClass() (r string, exists bool) {
	v := m.seat_class
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatClass returns the old "seat_class" field's value of the Seats entity.
// If the Seats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatsMutation) OldSeatClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatClass: %w", err)
	}
	return oldValue.SeatClass, nil
}

// ResetSeatClass resets all changes to the "seat_class" field.
func (m *SeatsMutation) ResetSeatClass() {
	m.seat_class = nil
}

// SetAircraftID sets the "aircraft" edge to the Aircraft entity by id.
func (m *SeatsMutation) SetAircraftID(id uuid.UUID) {
	m.aircraft = &id
}

// ClearAircraft clears the "aircraft" edge to the Aircraft entity.
func (m *SeatsMutation) ClearAircraft() {
	m.clearedaircraft = true
}

// AircraftCleared reports if the "aircraft" edge to the Aircraft entity was cleared.
func (m *SeatsMutation) AircraftCleared() bool {
	return m.clearedaircraft
}

// AircraftID returns the "aircraft" edge ID in the mutation.
func (m *SeatsMutation) AircraftID() (id uuid.UUID, exists bool) {
	if m.aircraft != nil {
		return *m.aircraft, true
	}
	return
}

// AircraftIDs returns the "aircraft" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AircraftID instead. It exists only for internal usage by the builders.
func (m *SeatsMutation) AircraftIDs() (ids []uuid.UUID) {
	if id := m.aircraft; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAircraft resets all changes to the "aircraft" edge.
func (m *SeatsMutation) ResetAircraft() {
	m.aircraft = nil
	m.clearedaircraft = false
}

// AddFlightInstanceIDs adds the "flight_instances" edge to the FlightSeat entity by ids.
func (m *SeatsMutation) AddFlightInstanceIDs(ids ...uuid.UUID) {
	if m.flight_instances == nil {
		m.flight_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_instances[ids[i]] = struct{}{}
	}
}

// ClearFlightInstances clears the "flight_instances" edge to the FlightSeat entity.
func (m *SeatsMutation) ClearFlightInstances() {
	m.clearedflight_instances = true
}

// FlightInstancesCleared reports if the "flight_instances" edge to the FlightSeat entity was cleared.
func (m *SeatsMutation) FlightInstancesCleared() bool {
	return m.clearedflight_instances
}

// RemoveFlightInstanceIDs removes the "flight_instances" edge to the FlightSeat entity by IDs.
func (m *SeatsMutation) RemoveFlightInstanceIDs(ids ...uuid.UUID) {
	if m.removedflight_instances == nil {
		m.removedflight_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_instances, ids[i])
		m.removedflight_instances[ids[i]] = struct{}{}
	}
}

// RemovedFlightInstances returns the removed IDs of the "flight_instances" edge to the FlightSeat entity.
func (m *SeatsMutation) RemovedFlightInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_instances {
		ids = append(ids, id)
	}
	return
}

// FlightInstancesIDs returns the "flight_instances" edge IDs in the mutation.
func (m *SeatsMutation) FlightInstancesIDs() (ids []uuid.UUID) {
	for id := range m.flight_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFlightInstances resets all changes to the "flight_instances" edge.
func (m *SeatsMutation) ResetFlightInstances() {
	m.flight_instances = nil
	m.clearedflight_instances = false
	m.removedflight_instances = nil
}

// Where appends a list predicates to the SeatsMutation builder.
func (m *SeatsMutation) Where(ps ...predicate.Seats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Seats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Seats).
func (m *SeatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeatsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.seat_number != nil {
		fields = append(fields, seats.FieldSeatNumber)
	}
	if m.seat_class != nil {
		fields = append(fields, seats.FieldSeatClass)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seats.FieldSeatNumber:
		return m.SeatNumber()
	case seats.FieldSeatClass:
		return m.SeatClass()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seats.FieldSeatNumber:
		return m.OldSeatNumber(ctx)
	case seats.FieldSeatClass:
		return m.OldSeatClass(ctx)
	}
	return nil, fmt.Errorf("unknown Seats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seats.FieldSeatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatNumber(v)
		return nil
	case seats.FieldSeatClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatClass(v)
		return nil
	}
	return fmt.Errorf("unknown Seats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeatsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeatsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Seats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeatsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeatsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Seats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeatsMutation) ResetField(name string) error {
	switch name {
	case seats.FieldSeatNumber:
		m.ResetSeatNumber()
		return nil
	case seats.FieldSeatClass:
		m.ResetSeatClass()
		return nil
	}
	return fmt.Errorf("unknown Seats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.aircraft != nil {
		edges = append(edges, seats.EdgeAircraft)
	}
	if m.flight_instances != nil {
		edges = append(edges, seats.EdgeFlightInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seats.EdgeAircraft:
		if id := m.aircraft; id != nil {
			return []ent.Value{*id}
		}
	case seats.EdgeFlightInstances:
		ids := make([]ent.Value, 0, len(m.flight_instances))
		for id := range m.flight_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflight_instances != nil {
		edges = append(edges, seats.EdgeFlightInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeatsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case seats.EdgeFlightInstances:
		ids := make([]ent.Value, 0, len(m.removedflight_instances))
		for id := range m.removedflight_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaircraft {
		edges = append(edges, seats.EdgeAircraft)
	}
	if m.clearedflight_instances {
		edges = append(edges, seats.EdgeFlightInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeatsMutation) EdgeCleared(name string) bool {
	switch name {
	case seats.EdgeAircraft:
		return m.clearedaircraft
	case seats.EdgeFlightInstances:
		return m.clearedflight_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeatsMutation) ClearEdge(name string) error {
	switch name {
	case seats.EdgeAircraft:
		m.ClearAircraft()
		return nil
	}
	return fmt.Errorf("unknown Seats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeatsMutation) ResetEdge(name string) error {
	switch name {
	case seats.EdgeAircraft:
		m.ResetAircraft()
		return nil
	case seats.EdgeFlightInstances:
		m.ResetFlightInstances()
		return nil
	}
	return fmt.Errorf("unknown Seats edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	email           *string
	password_hash   *string
	full_name       *string
	role            *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	bookings        map[uuid.UUID]struct{}
	removedbookings map[uuid.UUID]struct{}
	clearedbookings bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *UserMutation) AddBookingIDs(ids ...uuid.UUID) {
	if m.bookings == nil {
		m.bookings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *UserMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *UserMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *UserMutation) RemoveBookingIDs(ids ...uuid.UUID) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *UserMutation) RemovedBookingsIDs() (ids []uuid.UUID) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *UserMutation) BookingsIDs() (ids []uuid.UUID) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *UserMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbookings {
		edges = append(edges, user.EdgeBookings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBookings:
		return m.clearedbookings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBookings:
		m.ResetBookings()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
